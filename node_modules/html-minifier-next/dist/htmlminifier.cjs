'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var entities = require('entities');
var RelateURL = require('relateurl');

/*
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy “kangax” Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

/*
 * Use like so:
 *
 * HTMLParser(htmlString, {
 *   start: function(tag, attrs, unary) {},
 *   end: function(tag) {},
 *   chars: function(text) {},
 *   comment: function(text) {}
 * });
 */

class CaseInsensitiveSet extends Set {
  has(str) {
    return super.has(str.toLowerCase());
  }
}

// Regular expressions for parsing tags and attributes
const singleAttrIdentifier = /([^\s"'<>/=]+)/;
const singleAttrAssigns = [/=/];
const singleAttrValues = [
  // Attr value double quotes
  /"([^"]*)"+/.source,
  // Attr value, single quotes
  /'([^']*)'+/.source,
  // Attr value, no quotes
  /([^ \t\n\f\r"'`=<>]+)/.source
];
// https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
const qnameCapture = (function () {
  // https://www.npmjs.com/package/ncname
  const combiningChar = '\u0300-\u0345\u0360\u0361\u0483-\u0486\u0591-\u05A1\u05A3-\u05B9\u05BB-\u05BD\u05BF\u05C1\u05C2\u05C4\u064B-\u0652\u0670\u06D6-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0901-\u0903\u093C\u093E-\u094D\u0951-\u0954\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A02\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A70\u0A71\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0B01-\u0B03\u0B3C\u0B3E-\u0B43\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B82\u0B83\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C82\u0C83\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D43\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86-\u0F8B\u0F90-\u0F95\u0F97\u0F99-\u0FAD\u0FB1-\u0FB7\u0FB9\u20D0-\u20DC\u20E1\u302A-\u302F\u3099\u309A';
  const digit = '0-9\u0660-\u0669\u06F0-\u06F9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE7-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29';
  const extender = '\xB7\u02D0\u02D1\u0387\u0640\u0E46\u0EC6\u3005\u3031-\u3035\u309D\u309E\u30FC-\u30FE';
  const letter = 'A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u0131\u0134-\u013E\u0141-\u0148\u014A-\u017E\u0180-\u01C3\u01CD-\u01F0\u01F4\u01F5\u01FA-\u0217\u0250-\u02A8\u02BB-\u02C1\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03CE\u03D0-\u03D6\u03DA\u03DC\u03DE\u03E0\u03E2-\u03F3\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E-\u0481\u0490-\u04C4\u04C7\u04C8\u04CB\u04CC\u04D0-\u04EB\u04EE-\u04F5\u04F8\u04F9\u0531-\u0556\u0559\u0561-\u0586\u05D0-\u05EA\u05F0-\u05F2\u0621-\u063A\u0641-\u064A\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D3\u06D5\u06E5\u06E6\u0905-\u0939\u093D\u0958-\u0961\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8B\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AE0\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B36-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB5\u0BB7-\u0BB9\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CDE\u0CE0\u0CE1\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D60\u0D61\u0E01-\u0E2E\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD\u0EAE\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0F40-\u0F47\u0F49-\u0F69\u10A0-\u10C5\u10D0-\u10F6\u1100\u1102\u1103\u1105-\u1107\u1109\u110B\u110C\u110E-\u1112\u113C\u113E\u1140\u114C\u114E\u1150\u1154\u1155\u1159\u115F-\u1161\u1163\u1165\u1167\u1169\u116D\u116E\u1172\u1173\u1175\u119E\u11A8\u11AB\u11AE\u11AF\u11B7\u11B8\u11BA\u11BC-\u11C2\u11EB\u11F0\u11F9\u1E00-\u1E9B\u1EA0-\u1EF9\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2126\u212A\u212B\u212E\u2180-\u2182\u3007\u3021-\u3029\u3041-\u3094\u30A1-\u30FA\u3105-\u312C\u4E00-\u9FA5\uAC00-\uD7A3';
  const ncname = '[' + letter + '_][' + letter + digit + '\\.\\-_' + combiningChar + extender + ']*';
  return '((?:' + ncname + '\\:)?' + ncname + ')';
})();
const startTagOpen = new RegExp('^<' + qnameCapture);
const startTagClose = /^\s*(\/?)>/;
const endTag = new RegExp('^</' + qnameCapture + '[^>]*>');
const doctype = /^<!DOCTYPE\s?[^>]+>/i;

let IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Empty elements
const empty = new CaseInsensitiveSet(['area', 'base', 'basefont', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);

// Inline elements
const inline = new CaseInsensitiveSet(['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo', 'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'noscript', 'object', 'q', 's', 'samp', 'script', 'select', 'selectedcontent', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'svg', 'textarea', 'tt', 'u', 'var']);

// Elements that you can, intentionally, leave open (and which close themselves)
const closeSelf = new CaseInsensitiveSet(['colgroup', 'dd', 'dt', 'li', 'option', 'p', 'td', 'tfoot', 'th', 'thead', 'tr', 'source']);

// Attributes that have their values filled in `disabled='disabled'`
const fillAttrs = new CaseInsensitiveSet(['checked', 'compact', 'declare', 'defer', 'disabled', 'ismap', 'multiple', 'nohref', 'noresize', 'noshade', 'nowrap', 'readonly', 'selected']);

// Special elements (can contain anything)
const special = new CaseInsensitiveSet(['script', 'style']);

// HTML elements, https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing content, https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
const nonPhrasing = new CaseInsensitiveSet(['address', 'article', 'aside', 'base', 'blockquote', 'body', 'caption', 'col', 'colgroup', 'dd', 'details', 'dialog', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'legend', 'li', 'menuitem', 'meta', 'ol', 'optgroup', 'option', 'param', 'rp', 'rt', 'source', 'style', 'summary', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul']);

const reCache = {};

// Pre-compiled regexes for common special elements (`script`, `style`, `noscript`)
// These are used frequently, and pre-compiling them avoids regex creation overhead
const preCompiledStackedTags = {
  'script': /([\s\S]*?)<\/script[^>]*>/i,
  'style': /([\s\S]*?)<\/style[^>]*>/i,
  'noscript': /([\s\S]*?)<\/noscript[^>]*>/i
};

// Cache for compiled attribute regexes per handler configuration
const attrRegexCache = new WeakMap();

function buildAttrRegex(handler) {
  let pattern = singleAttrIdentifier.source +
    '(?:\\s*(' + joinSingleAttrAssigns(handler) + ')' +
    '[ \\t\\n\\f\\r]*(?:' + singleAttrValues.join('|') + '))?';
  if (handler.customAttrSurround) {
    const attrClauses = [];
    for (let i = handler.customAttrSurround.length - 1; i >= 0; i--) {
      attrClauses[i] = '(?:' +
        '(' + handler.customAttrSurround[i][0].source + ')\\s*' +
        pattern +
        '\\s*(' + handler.customAttrSurround[i][1].source + ')' +
        ')';
    }
    attrClauses.push('(?:' + pattern + ')');
    pattern = '(?:' + attrClauses.join('|') + ')';
  }
  return new RegExp('^\\s*' + pattern);
}

function getAttrRegexForHandler(handler) {
  let cached = attrRegexCache.get(handler);
  if (cached) return cached;
  const compiled = buildAttrRegex(handler);
  attrRegexCache.set(handler, compiled);
  return compiled;
}

function joinSingleAttrAssigns(handler) {
  return singleAttrAssigns.concat(
    handler.customAttrAssign || []
  ).map(function (assign) {
    return '(?:' + assign.source + ')';
  }).join('|');
}

// Number of captured parts per `customAttrSurround` pattern
const NCP = 7;

class HTMLParser {
  constructor(html, handler) {
    this.html = html;
    this.handler = handler;
  }

  async parse() {
    const handler = this.handler;
    const fullHtml = this.html;
    const fullLength = fullHtml.length;

    const stack = []; let lastTag;
    // Use cached attribute regex for this handler configuration
    const attribute = getAttrRegexForHandler(handler);
    let prevTag = undefined, nextTag = undefined;
    let prevAttrs = [], nextAttrs = [];

    // Index-based parsing
    let pos = 0;
    let lastPos;

    // Helper to advance position
    const advance = (n) => { pos += n; };

    // Lazy line/column calculation—only compute on actual errors
    const getLineColumn = (position) => {
      let line = 1;
      let column = 1;
      for (let i = 0; i < position; i++) {
        if (fullHtml[i] === '\n') {
          line++;
          column = 1;
        } else {
          column++;
        }
      }
      return { line, column };
    };

    // Helper to safely extract substring when needed for regex operations
    const sliceFromPos = (startPos, len) => {
      const endPos = fullLength;
      return fullHtml.slice(startPos, endPos);
    };

    while (pos < fullLength) {
      lastPos = pos;

      // Make sure we’re not in a `script` or `style` element
      if (!lastTag || !special.has(lastTag)) {
        const textEnd = fullHtml.indexOf('<', pos);

        if (textEnd === pos) {
          // We found a tag at current position
          const remaining = sliceFromPos(pos);

          // Comment
          if (/^<!--/.test(remaining)) {
            const commentEnd = fullHtml.indexOf('-->', pos + 4);

            if (commentEnd >= 0) {
              if (handler.comment) {
                await handler.comment(fullHtml.substring(pos + 4, commentEnd));
              }
              advance(commentEnd + 3 - pos);
              prevTag = '';
              prevAttrs = [];
              continue;
            }
          }

          // https://web.archive.org/web/20241201212701/https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (/^<!\[/.test(remaining)) {
            const conditionalEnd = fullHtml.indexOf(']>', pos + 3);

            if (conditionalEnd >= 0) {
              if (handler.comment) {
                await handler.comment(fullHtml.substring(pos + 2, conditionalEnd + 1), true /* Non-standard */);
              }
              advance(conditionalEnd + 2 - pos);
              prevTag = '';
              prevAttrs = [];
              continue;
            }
          }

          // Doctype
          if (doctype.test(remaining)) {
            const doctypeMatch = remaining.match(doctype);
            if (handler.doctype) {
              handler.doctype(doctypeMatch[0]);
            }
            advance(doctypeMatch[0].length);
            prevTag = '';
            prevAttrs = [];
            continue;
          }

          // End tag
          if (endTag.test(remaining)) {
            const endTagMatch = remaining.match(endTag);
            advance(endTagMatch[0].length);
            await parseEndTag(endTagMatch[0], endTagMatch[1]);
            prevTag = '/' + endTagMatch[1].toLowerCase();
            prevAttrs = [];
            continue;
          }

          // Start tag
          const startTagMatch = parseStartTag(remaining, pos);
          if (startTagMatch) {
            advance(startTagMatch.advance);
            await handleStartTag(startTagMatch);
            prevTag = startTagMatch.tagName.toLowerCase();
            continue;
          }

          // Treat `<` as text
          if (handler.continueOnParseError) ;
        }

        let text;
        if (textEnd >= 0) {
          text = fullHtml.substring(pos, textEnd);
          advance(textEnd - pos);
        } else {
          text = fullHtml.substring(pos);
          advance(fullLength - pos);
        }

        // Next tag for whitespace processing context
        const remainingAfterText = sliceFromPos(pos);
        let nextTagMatch = parseStartTag(remainingAfterText, pos);
        if (nextTagMatch) {
          nextTag = nextTagMatch.tagName;
          // Extract minimal attribute info for whitespace logic (just name/value pairs)
          nextAttrs = extractAttrInfo(nextTagMatch.attrs);
        } else {
          const endTagMatch = remainingAfterText.match(endTag);
          if (endTagMatch) {
            nextTag = '/' + endTagMatch[1];
            nextAttrs = [];
          } else {
            nextTag = '';
            nextAttrs = [];
          }
        }

        if (handler.chars) {
          await handler.chars(text, prevTag, nextTag, prevAttrs, nextAttrs);
        }
        prevTag = '';
        prevAttrs = [];
      } else {
        const stackedTag = lastTag.toLowerCase();
        // Use pre-compiled regex for common tags (`script`, `style`, `noscript`) to avoid regex creation overhead
        const reStackedTag = preCompiledStackedTags[stackedTag] || reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)\\x3c/' + stackedTag + '[^>]*>', 'i'));

        const remaining = sliceFromPos(pos);
        const m = reStackedTag.exec(remaining);
        if (m && m.index === 0) {
          let text = m[1];
          if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
            text = text
              .replace(/<!--([\s\S]*?)-->/g, '$1')
              .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (handler.chars) {
            await handler.chars(text);
          }
          // Advance HTML past the matched special tag content and its closing tag
          advance(m[0].length);
          await parseEndTag('</' + stackedTag + '>', stackedTag);
        } else {
          // No closing tag found; to avoid infinite loop, break similarly to previous behavior
          if (handler.continueOnParseError && handler.chars && pos < fullLength) {
            await handler.chars(fullHtml[pos], prevTag, '', prevAttrs, []);
            advance(1);
          } else {
            break;
          }
        }
      }

      if (pos === lastPos) {
        if (handler.continueOnParseError) {
          // Skip the problematic character and continue
          if (handler.chars) {
            await handler.chars(fullHtml[pos], prevTag, '', prevAttrs, []);
          }
          advance(1);
          prevTag = '';
          prevAttrs = [];
          continue;
        }
        const loc = getLineColumn(pos);
        // Include some context before the error position so the snippet contains the offending markup plus preceding characters (e.g., `invalid<tag`)
        const CONTEXT_BEFORE = 50;
        const startPos = Math.max(0, pos - CONTEXT_BEFORE);
        const snippet = fullHtml.slice(startPos, startPos + 200).replace(/\n/g, ' ');
        throw new Error(
          `Parse error at line ${loc.line}, column ${loc.column}:\n${snippet}${fullHtml.length > startPos + 200 ? '…' : ''}`
        );
      }
    }

    if (!handler.partialMarkup) {
      // Clean up any remaining tags
      await parseEndTag();
    }

    // Helper to extract minimal attribute info (name/value pairs) from raw attribute matches
    // Used for whitespace collapsing logic—doesn’t need full processing
    function extractAttrInfo(rawAttrs) {
      if (!rawAttrs || !rawAttrs.length) return [];

      const numCustomParts = handler.customAttrSurround ? handler.customAttrSurround.length * NCP : 0;
      const baseIndex = 1 + numCustomParts;

      return rawAttrs.map(args => {
        // Extract attribute name (always at `baseIndex`)
        const name = args[baseIndex];
        // Extract value from double-quoted (`baseIndex + 2`), single-quoted (`baseIndex + 3`), or unquoted (`baseIndex + 4`)
        const value = args[baseIndex + 2] ?? args[baseIndex + 3] ?? args[baseIndex + 4];
        return { name: name?.toLowerCase(), value };
      }).filter(attr => attr.name); // Filter out invalid entries
    }

    function parseStartTag(remaining, startPos) {
      const start = remaining.match(startTagOpen);
      if (start) {
        const match = {
          tagName: start[1],
          attrs: [],
          advance: 0
        };
        let consumed = start[0].length;
        let currentPos = startPos + consumed;
        let end, attr;

        // Safety limit: Max length of input to check for attributes
        // Protects against catastrophic backtracking on massive attribute values
        const MAX_ATTR_PARSE_LENGTH = 20000; // 20 KB should be enough for any reasonable tag

        while (true) {
          // Check for closing tag first
          const remainingForEnd = sliceFromPos(currentPos);
          end = remainingForEnd.match(startTagClose);
          if (end) {
            break;
          }

          // Limit the input length we pass to the regex to prevent catastrophic backtracking
          const remainingLen = fullLength - currentPos;
          const isLimited = remainingLen > MAX_ATTR_PARSE_LENGTH;
          const extractEndPos = isLimited ? currentPos + MAX_ATTR_PARSE_LENGTH : fullLength;

          // Create a temporary substring only for attribute parsing (this is limited and necessary for regex)
          const searchStr = fullHtml.substring(currentPos, extractEndPos);
          attr = searchStr.match(attribute);

          // If we limited the input and got a match, check if the value might be truncated
          if (attr && isLimited) {
            // Check if the attribute value extends beyond our search window
            const attrEnd = attr[0].length;
            // If the match ends near the limit, the value might be truncated
            if (attrEnd > MAX_ATTR_PARSE_LENGTH - 100) {
              // Manually extract this attribute to handle potentially huge value
              const manualMatch = searchStr.match(/^\s*([^\s"'<>/=]+)\s*=\s*/);
              if (manualMatch) {
                const quoteChar = searchStr[manualMatch[0].length];
                if (quoteChar === '"' || quoteChar === "'") {
                  const closeQuote = searchStr.indexOf(quoteChar, manualMatch[0].length + 1);
                  if (closeQuote !== -1) {
                    const fullAttrLen = closeQuote + 1;
                    const numCustomParts = handler.customAttrSurround
                      ? handler.customAttrSurround.length * NCP
                      : 0;
                    const baseIndex = 1 + numCustomParts;

                    attr = [];
                    attr[0] = searchStr.substring(0, fullAttrLen);
                    attr[baseIndex] = manualMatch[1]; // Attribute name
                    attr[baseIndex + 1] = '='; // `customAssign` (falls back to "=" for huge attributes)
                    const value = searchStr.substring(manualMatch[0].length + 1, closeQuote);
                    // Place value at correct index based on quote type
                    if (quoteChar === '"') {
                      attr[baseIndex + 2] = value; // Double-quoted value
                    } else {
                      attr[baseIndex + 3] = value; // Single-quoted value
                    }
                    currentPos += fullAttrLen;
                    consumed += fullAttrLen;
                    match.attrs.push(attr);
                    continue;
                  }
                }
                // Note: Unquoted attribute values are intentionally not handled here.
                // Per HTML spec, unquoted values cannot contain spaces or special chars,
                // making a 20 KB+ unquoted value practically impossible. If encountered,
                // it’s malformed HTML and using the truncated regex match is acceptable.
              }
            }
          }

          if (!attr && isLimited) {
            // If we limited the input and got no match, try manual extraction
            // This handles cases where quoted attributes exceed `MAX_ATTR_PARSE_LENGTH`
            const manualMatch = searchStr.match(/^\s*([^\s"'<>/=]+)\s*=\s*/);
            if (manualMatch) {
              const quoteChar = searchStr[manualMatch[0].length];
              if (quoteChar === '"' || quoteChar === "'") {
                // Search in the full HTML (not limited substring) for closing quote
                const closeQuote = fullHtml.indexOf(quoteChar, currentPos + manualMatch[0].length + 1);
                if (closeQuote !== -1) {
                  const fullAttrLen = closeQuote - currentPos + 1;
                  const numCustomParts = handler.customAttrSurround
                    ? handler.customAttrSurround.length * NCP
                    : 0;
                  const baseIndex = 1 + numCustomParts;

                  attr = [];
                  attr[0] = fullHtml.substring(currentPos, closeQuote + 1);
                  attr[baseIndex] = manualMatch[1]; // Attribute name
                  attr[baseIndex + 1] = '='; // customAssign
                  const value = fullHtml.substring(currentPos + manualMatch[0].length + 1, closeQuote);
                  // Place value at correct index based on quote type
                  if (quoteChar === '"') {
                    attr[baseIndex + 2] = value; // Double-quoted value
                  } else {
                    attr[baseIndex + 3] = value; // Single-quoted value
                  }
                  currentPos += fullAttrLen;
                  consumed += fullAttrLen;
                  match.attrs.push(attr);
                  continue;
                }
              }
            }
          }

          if (!attr) {
            break;
          }

          const attrLen = attr[0].length;
          currentPos += attrLen;
          consumed += attrLen;
          match.attrs.push(attr);
        }

        // Check for closing tag
        const remainingForClose = sliceFromPos(currentPos);
        end = remainingForClose.match(startTagClose);
        if (end) {
          match.unarySlash = end[1];
          consumed += end[0].length;
          match.advance = consumed;
          return match;
        }
      }
    }

    function findTagInCurrentTable(tagName) {
      let pos;
      const needle = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        const currentTag = stack[pos].lowerTag;
        if (currentTag === needle) {
          return pos;
        }
        // Stop searching if we hit a table boundary
        if (currentTag === 'table') {
          break;
        }
      }
      return -1;
    }

    async function parseEndTagAt(pos) {
      // Close all open elements up to `pos` (mirrors `parseEndTag`’s core branch)
      for (let i = stack.length - 1; i >= pos; i--) {
        if (handler.end) {
          await handler.end(stack[i].tag, stack[i].attrs, true);
        }
      }
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    }

    async function closeIfFoundInCurrentTable(tagName) {
      const pos = findTagInCurrentTable(tagName);
      if (pos >= 0) {
        // Close at the specific index to avoid re-searching
        await parseEndTagAt(pos);
        return true;
      }
      return false;
    }

    async function handleStartTag(match) {
      const tagName = match.tagName;
      let unarySlash = match.unarySlash;

      if (handler.html5) {
        if (lastTag === 'p' && nonPhrasing.has(tagName)) {
          await parseEndTag('', lastTag);
        } else if (tagName === 'tbody') {
          await closeIfFoundInCurrentTable('thead');
        } else if (tagName === 'tfoot') {
          if (!await closeIfFoundInCurrentTable('tbody')) {
            await closeIfFoundInCurrentTable('thead');
          }
        } else if (tagName === 'thead') {
          // If a `tbody` or `tfoot` is open in the current table, close it
          if (!await closeIfFoundInCurrentTable('tbody')) {
            await closeIfFoundInCurrentTable('tfoot');
          }
        }
        if (tagName === 'col' && findTag('colgroup') < 0) {
          lastTag = 'colgroup';
          stack.push({ tag: lastTag, lowerTag: 'colgroup', attrs: [] });
          if (handler.start) {
            await handler.start(lastTag, [], false, '');
          }
        }
      }

      if (!handler.html5 && !inline.has(tagName)) {
        while (lastTag && inline.has(lastTag)) {
          await parseEndTag('', lastTag);
        }
      }

      if (closeSelf.has(tagName) && lastTag === tagName) {
        await parseEndTag('', tagName);
      }

      // Handle `dt`/`dd` cross-closing: `dt` followed by `dd`, or `dd` followed by `dt`
      if ((tagName === 'dt' || tagName === 'dd') && (lastTag === 'dt' || lastTag === 'dd')) {
        await parseEndTag('', lastTag);
      }

      const unary = empty.has(tagName) || (tagName === 'html' && lastTag === 'head') || !!unarySlash;

      const attrs = match.attrs.map(function (args) {
        let name, value, customOpen, customClose, customAssign, quote;

        // Hackish workaround for Firefox bug, https://bugzilla.mozilla.org/show_bug.cgi?id=369778
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === '') { delete args[3]; }
          if (args[4] === '') { delete args[4]; }
          if (args[5] === '') { delete args[5]; }
        }

        function populate(index) {
          customAssign = args[index];
          value = args[index + 1];
          if (typeof value !== 'undefined') {
            return '"';
          }
          value = args[index + 2];
          if (typeof value !== 'undefined') {
            return '\'';
          }
          value = args[index + 3];
          if (typeof value === 'undefined' && fillAttrs.has(name)) {
            value = name;
          }
          return '';
        }

        let j = 1;
        if (handler.customAttrSurround) {
          for (let i = 0, l = handler.customAttrSurround.length; i < l; i++, j += NCP) {
            name = args[j + 1];
            if (name) {
              quote = populate(j + 2);
              customOpen = args[j];
              customClose = args[j + 6];
              break;
            }
          }
        }

        if (!name && (name = args[j])) {
          quote = populate(j + 1);
        }

        return {
          name,
          value,
          customAssign: customAssign || '=',
          customOpen: customOpen || '',
          customClose: customClose || '',
          quote: quote || ''
        };
      });

      if (!unary) {
        stack.push({ tag: tagName, lowerTag: tagName.toLowerCase(), attrs });
        lastTag = tagName;
        unarySlash = '';
      }

      // Store attributes for `prevAttrs` tracking (used in whitespace collapsing)
      prevAttrs = attrs;

      if (handler.start) {
        await handler.start(tagName, attrs, unary, unarySlash);
      }
    }

    function findTag(tagName) {
      let pos;
      const needle = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerTag === needle) {
          break;
        }
      }
      return pos;
    }

    async function parseEndTag(tag, tagName) {
      let pos;

      // Find the closest opened tag of the same type
      if (tagName) {
        pos = findTag(tagName);
      } else { // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (let i = stack.length - 1; i >= pos; i--) {
          if (handler.end) {
            handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (handler.partialMarkup && tagName) {
        // In partial markup mode, preserve stray end tags
        if (handler.end) {
          handler.end(tagName, [], false);
        }
      } else if (tagName && tagName.toLowerCase() === 'br') {
        if (handler.start) {
          await handler.start(tagName, [], true, '');
        }
      } else if (tagName && tagName.toLowerCase() === 'p') {
        if (handler.start) {
          await handler.start(tagName, [], false, '', true);
        }
        if (handler.end) {
          handler.end(tagName, []);
        }
      }
    }
  }
}

class Sorter {
  sort(tokens, fromIndex = 0) {
    for (let i = 0, len = this.keys.length; i < len; i++) {
      const token = this.keys[i];

      // Single pass: Count matches and collect non-matches
      let matchCount = 0;
      const others = [];

      for (let j = fromIndex; j < tokens.length; j++) {
        if (tokens[j] === token) {
          matchCount++;
        } else {
          others.push(tokens[j]);
        }
      }

      if (matchCount > 0) {
        // Rebuild: `matchCount` instances of token first, then others
        let writeIdx = fromIndex;
        for (let j = 0; j < matchCount; j++) {
          tokens[writeIdx++] = token;
        }
        for (let j = 0; j < others.length; j++) {
          tokens[writeIdx++] = others[j];
        }

        const newFromIndex = fromIndex + matchCount;
        return this.sorterMap.get(token).sort(tokens, newFromIndex);
      }
    }
    return tokens;
  }
}

class TokenChain {
  constructor() {
    // Use map instead of object properties for better performance
    this.map = new Map();
  }

  add(tokens) {
    tokens.forEach((token) => {
      if (!this.map.has(token)) {
        this.map.set(token, { arrays: [], processed: 0 });
      }
      this.map.get(token).arrays.push(tokens);
    });
  }

  createSorter() {
    const sorter = new Sorter();
    sorter.sorterMap = new Map();

    // Convert map entries to array and sort by frequency (descending), then alphabetically
    const entries = Array.from(this.map.entries()).sort((a, b) => {
      const m = a[1].arrays.length;
      const n = b[1].arrays.length;
      // Sort by length descending (larger first)
      const lengthDiff = n - m;
      if (lengthDiff !== 0) return lengthDiff;
      // If lengths equal, sort by key ascending
      return a[0].localeCompare(b[0]);
    });

    sorter.keys = [];

    entries.forEach(([token, data]) => {
      if (data.processed < data.arrays.length) {
        const chain = new TokenChain();

        data.arrays.forEach((tokens) => {
          // Build new array without the current token instead of splicing
          const filtered = [];
          for (let i = 0; i < tokens.length; i++) {
            if (tokens[i] !== token) {
              filtered.push(tokens[i]);
            }
          }

          // Mark remaining tokens as processed
          filtered.forEach((t) => {
            const tData = this.map.get(t);
            if (tData) {
              tData.processed++;
            }
          });

          if (filtered.length > 0) {
            chain.add(filtered);
          }
        });

        sorter.keys.push(token);
        sorter.sorterMap.set(token, chain.createSorter());
      }
    });

    return sorter;
  }
}

/**
 * Preset configurations
 *
 * Presets provide curated option sets for common use cases:
 * - `conservative`: Safe minification suitable for most projects
 * - `comprehensive`: Aggressive minification for maximum file size reduction
 */

const presets = {
  conservative: {
    collapseBooleanAttributes: true,
    collapseWhitespace: true,
    conservativeCollapse: true,
    continueOnParseError: true,
    decodeEntities: true,
    minifyURLs: true,
    noNewlinesBeforeTagClose: true,
    preserveLineBreaks: true,
    removeComments: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    useShortDoctype: true
  },
  comprehensive: {
    caseSensitive: true,
    collapseBooleanAttributes: true,
    collapseWhitespace: true,
    continueOnParseError: true,
    decodeEntities: true,
    mergeScripts: true,
    minifyCSS: true,
    minifyJS: true,
    minifySVG: true,
    minifyURLs: true,
    noNewlinesBeforeTagClose: true,
    processConditionalComments: true,
    removeAttributeQuotes: true,
    removeComments: true,
    removeEmptyAttributes: true,
    removeOptionalTags: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    sortAttributes: true,
    sortClassName: true,
    useShortDoctype: true
  }
};

/**
 * Get preset configuration by name
 * @param {string} name - Preset name (“conservative” or “comprehensive”)
 * @returns {object|null} Preset options object or null if not found
 */
function getPreset(name) {
  if (!name) return null;
  const normalizedName = name.toLowerCase();
  return presets[normalizedName] || null;
}

/**
 * Get list of available preset names
 * @returns {string[]} Array of preset names
 */
function getPresetNames() {
  return Object.keys(presets);
}

// Stringify for options signatures (sorted keys, shallow, nested objects)

function stableStringify(obj) {
  if (obj == null || typeof obj !== 'object') return JSON.stringify(obj);
  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';
  const keys = Object.keys(obj).sort();
  let out = '{';
  for (let i = 0; i < keys.length; i++) {
    const k = keys[i];
    out += JSON.stringify(k) + ':' + stableStringify(obj[k]) + (i < keys.length - 1 ? ',' : '');
  }
  return out + '}';
}

// LRU cache for strings and promises

class LRU {
  constructor(limit = 200) {
    this.limit = limit;
    this.map = new Map();
  }
  get(key) {
    if (this.map.has(key)) {
      const v = this.map.get(key);
      this.map.delete(key);
      this.map.set(key, v);
      return v;
    }
    return undefined;
  }
  set(key, value) {
    if (this.map.has(key)) this.map.delete(key);
    this.map.set(key, value);
    if (this.map.size > this.limit) {
      const first = this.map.keys().next().value;
      this.map.delete(first);
    }
  }
  delete(key) { this.map.delete(key); }
}

// Unique ID generator

function uniqueId(value) {
  let id;
  do {
    id = Math.random().toString(36).replace(/^0\.[0-9]*/, '');
  } while (~value.indexOf(id));
  return id;
}

// Identity functions

function identity(value) {
  return value;
}

function identityAsync(value) {
  return Promise.resolve(value);
}

// Replace async helper

/**
 * Asynchronously replace matches in a string
 * @param {string} str - Input string
 * @param {RegExp} regex - Regular expression with global flag
 * @param {Function} asyncFn - Async function to process each match
 * @returns {Promise<string>} Processed string
 */
async function replaceAsync(str, regex, asyncFn) {
  const promises = [];

  str.replace(regex, (match, ...args) => {
    const promise = asyncFn(match, ...args);
    promises.push(promise);
  });

  const data = await Promise.all(promises);
  return str.replace(regex, () => data.shift());
}

// Regex patterns (to avoid repeated allocations in hot paths)

const RE_WS_START = /^[ \n\r\t\f]+/;
const RE_WS_END = /[ \n\r\t\f]+$/;
const RE_ALL_WS_NBSP = /[ \n\r\t\f\xA0]+/g;
const RE_NBSP_LEADING_GROUP = /(^|\xA0+)[^\xA0]+/g;
const RE_NBSP_LEAD_GROUP = /(\xA0+)[^\xA0]+/g;
const RE_NBSP_TRAILING_GROUP = /[^\xA0]+(\xA0+)/g;
const RE_NBSP_TRAILING_STRIP = /[^\xA0]+$/;
const RE_CONDITIONAL_COMMENT = /^\[if\s[^\]]+]|\[endif]$/;
const RE_EVENT_ATTR_DEFAULT = /^on[a-z]{3,}$/;
const RE_CAN_REMOVE_ATTR_QUOTES = /^[^ \t\n\f\r"'`=<>]+$/;
const RE_TRAILING_SEMICOLON = /;$/;
const RE_AMP_ENTITY = /&(#?[0-9a-zA-Z]+;)/g;
const RE_LEGACY_ENTITIES = /&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g;
const RE_ESCAPE_LT = /</g;
const RE_ATTR_WS_CHECK = /[ \n\r\t\f]/;
const RE_ATTR_WS_COLLAPSE = /[ \n\r\t\f]+/g;
const RE_ATTR_WS_TRIM = /^[ \n\r\t\f]+|[ \n\r\t\f]+$/g;
const RE_NUMERIC_VALUE = /-?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;

// Inline element sets for whitespace handling

// Non-empty elements that will maintain whitespace around them
const inlineElementsToKeepWhitespaceAround = new Set(['a', 'abbr', 'acronym', 'b', 'bdi', 'bdo', 'big', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'mark', 'math', 'meter', 'nobr', 'object', 'output', 'progress', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'svg', 'textarea', 'time', 'tt', 'u', 'var', 'wbr']);

// Non-empty elements that will maintain whitespace within them
const inlineElementsToKeepWhitespaceWithin = new Set(['a', 'abbr', 'acronym', 'b', 'big', 'del', 'em', 'font', 'i', 'ins', 'kbd', 'mark', 'nobr', 's', 'samp', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'time', 'tt', 'u', 'var']);

// Elements that will always maintain whitespace around them
const inlineElementsToKeepWhitespace = new Set(['comment', 'img', 'input', 'wbr']);

// Form control elements (for conditional whitespace collapsing)
const formControlElements = new Set(['input', 'button', 'select', 'textarea', 'output', 'meter', 'progress']);

// Default attribute values

// Default attribute values (could apply to any element)
const generalDefaults = {
  autocorrect: 'on',
  fetchpriority: 'auto',
  loading: 'eager',
  popovertargetaction: 'toggle'
};

// Tag-specific default attribute values
const tagDefaults = {
  area: { shape: 'rect' },
  button: { type: 'submit' },
  form: {
    enctype: 'application/x-www-form-urlencoded',
    method: 'get'
  },
  html: { dir: 'ltr' },
  img: { decoding: 'auto' },
  input: {
    colorspace: 'limited-srgb',
    type: 'text'
  },
  link: { media: 'all' },
  marquee: {
    behavior: 'scroll',
    direction: 'left'
  },
  meta: { media: 'all' },
  source: { media: 'all' },
  style: { media: 'all' },
  textarea: { wrap: 'soft' },
  track: { kind: 'subtitles' }
};

// Script MIME types

// https://mathiasbynens.be/demo/javascript-mime-type
// https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/script
const executableScriptsMimetypes = new Set([
  'text/javascript',
  'text/x-javascript',
  'text/ecmascript',
  'text/x-ecmascript',
  'text/jscript',
  'application/javascript',
  'application/x-javascript',
  'application/ecmascript',
  'application/x-ecmascript',
  'module'
]);

const keepScriptsMimetypes = new Set([
  'module'
]);

// Boolean attribute sets

const isSimpleBoolean = new Set(['allowfullscreen', 'async', 'autofocus', 'autoplay', 'checked', 'compact', 'controls', 'declare', 'default', 'defaultchecked', 'defaultmuted', 'defaultselected', 'defer', 'disabled', 'enabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nohref', 'noresize', 'noshade', 'novalidate', 'nowrap', 'open', 'pauseonexit', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'sortable', 'truespeed', 'typemustmatch', 'visible']);

const isBooleanValue = new Set(['true', 'false']);

// Attributes where empty value can be collapsed to just the attribute name
// `crossorigin=""` → `crossorigin` (empty string equals anonymous mode)
// `contenteditable=""` → `contenteditable` (empty string equals `true`)
const emptyCollapsible = new Set(['crossorigin', 'contenteditable']);

// `srcset` elements

const srcsetElements = new Set(['img', 'source']);

// JSON script types

const jsonScriptTypes = new Set([
  'application/json',
  'application/ld+json',
  'application/manifest+json',
  'application/vnd.geo+json',
  'application/problem+json',
  'application/merge-patch+json',
  'application/json-patch+json',
  'importmap',
  'speculationrules',
]);

// Tag omission rules and element sets

// Tag omission rules from https://html.spec.whatwg.org/multipage/syntax.html#optional-tags with the following extensions:
// - retain `<body>` if followed by `<noscript>`
// - `<rb>`, `<rt>`, `<rtc>`, `<rp>` follow HTML Ruby Markup Extensions draft (https://www.w3.org/TR/html-ruby-extensions/)
// - retain all tags which are adjacent to non-standard HTML tags

const optionalStartTags = new Set(['html', 'head', 'body', 'colgroup', 'tbody']);

const optionalEndTags = new Set(['html', 'head', 'body', 'li', 'dt', 'dd', 'p', 'rb', 'rt', 'rtc', 'rp', 'optgroup', 'option', 'colgroup', 'caption', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th']);

const headerElements = new Set(['meta', 'link', 'script', 'style', 'template', 'noscript']);

const descriptionElements = new Set(['dt', 'dd']);

const pBlockElements = new Set(['address', 'article', 'aside', 'blockquote', 'details', 'dialog', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'search', 'section', 'table', 'ul']);

const pInlineElements = new Set(['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video']);

const rubyEndTagOmission = new Set(['rb', 'rt', 'rtc', 'rp']); // `</rb>`, `</rt>`, `</rp>` can be omitted if followed by `<rb>`, `<rt>`, `<rtc>`, or `<rp>`

const rubyRtcEndTagOmission = new Set(['rb', 'rtc']); // `</rtc>` can be omitted if followed by `<rb>` or `<rtc>` (not `<rt>` or `<rp>`)

const optionElements = new Set(['option', 'optgroup']);

const tableContentElements = new Set(['tbody', 'tfoot']);

const tableSectionElements = new Set(['thead', 'tbody', 'tfoot']);

const cellElements = new Set(['td', 'th']);

const topLevelElements = new Set(['html', 'head', 'body']);

const compactElements = new Set(['html', 'body']);

const looseElements = new Set(['head', 'colgroup', 'caption']);

const trailingElements = new Set(['dt', 'thead']);

const htmlElements = new Set(['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'search', 'section', 'select', 'selectedcontent', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp']);

// Empty attribute regex

const reEmptyAttribute = new RegExp(
  '^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(' +
  '?:down|up|over|move|out)|key(?:press|down|up)))$');

// Special content elements

const specialContentElements = new Set(['script', 'style']);

// Imports


// Trim whitespace

const trimWhitespace = str => {
  if (!str) return str;
  // Fast path: If no whitespace at start or end, return early
  if (!/^[ \n\r\t\f]/.test(str) && !/[ \n\r\t\f]$/.test(str)) {
    return str;
  }
  return str.replace(RE_WS_START, '').replace(RE_WS_END, '');
};

// Collapse all whitespace

function collapseWhitespaceAll(str) {
  if (!str) return str;
  // Fast path: If there are no common whitespace characters, return early
  if (!/[ \n\r\t\f\xA0]/.test(str)) {
    return str;
  }
  // No-break space is specifically handled inside the replacer function here:
  return str.replace(RE_ALL_WS_NBSP, function (spaces) {
    // Preserve standalone tabs
    if (spaces === '\t') return '\t';
    // Fast path: No no-break space, common case—just collapse to single space
    // This avoids the nested regex for the majority of cases
    if (spaces.indexOf('\xA0') === -1) return ' ';
    // For no-break space handling, use the original regex approach
    return spaces.replace(RE_NBSP_LEADING_GROUP, '$1 ');
  });
}

// Collapse whitespace with options

function collapseWhitespace(str, options, trimLeft, trimRight, collapseAll) {
  let lineBreakBefore = ''; let lineBreakAfter = '';

  if (!str) return str;

  // Fast path: Nothing to do
  if (!trimLeft && !trimRight && !collapseAll && !options.preserveLineBreaks) {
    return str;
  }

  // Fast path: No whitespace at all
  if (!/[ \n\r\t\f\xA0]/.test(str)) {
    return str;
  }

  if (options.preserveLineBreaks) {
    str = str.replace(/^[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*/, function () {
      lineBreakBefore = '\n';
      return '';
    }).replace(/[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*$/, function () {
      lineBreakAfter = '\n';
      return '';
    });
  }

  if (trimLeft) {
    // No-break space is specifically handled inside the replacer function
    str = str.replace(/^[ \n\r\t\f\xA0]+/, function (spaces) {
      const conservative = !lineBreakBefore && options.conservativeCollapse;
      if (conservative && spaces === '\t') {
        return '\t';
      }
      return spaces.replace(/^[^\xA0]+/, '').replace(RE_NBSP_LEAD_GROUP, '$1 ') || (conservative ? ' ' : '');
    });
  }

  if (trimRight) {
    // No-break space is specifically handled inside the replacer function
    str = str.replace(/[ \n\r\t\f\xA0]+$/, function (spaces) {
      const conservative = !lineBreakAfter && options.conservativeCollapse;
      if (conservative && spaces === '\t') {
        return '\t';
      }
      return spaces.replace(RE_NBSP_TRAILING_GROUP, ' $1').replace(RE_NBSP_TRAILING_STRIP, '') || (conservative ? ' ' : '');
    });
  }

  if (collapseAll) {
    // Strip non-space whitespace then compress spaces to one
    str = collapseWhitespaceAll(str);
  }

  // Avoid string concatenation when no line breaks (common case)
  if (!lineBreakBefore && !lineBreakAfter) return str;
  if (!lineBreakBefore) return str + lineBreakAfter;
  if (!lineBreakAfter) return lineBreakBefore + str;
  return lineBreakBefore + str + lineBreakAfter;
}

// Collapse whitespace smartly based on surrounding tags

function collapseWhitespaceSmart(str, prevTag, nextTag, prevAttrs, nextAttrs, options, inlineElements, inlineTextSet) {
  const prevTagName = prevTag && (prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag);
  const nextTagName = nextTag && (nextTag.charAt(0) === '/' ? nextTag.slice(1) : nextTag);

  // Helper: Check if an input element has `type="hidden"`
  const isHiddenInput = (tagName, attrs) => {
    if (tagName !== 'input' || !attrs || !attrs.length) return false;
    const typeAttr = attrs.find(attr => attr.name === 'type');
    return typeAttr && typeAttr.value === 'hidden';
  };

  // Check if prev/next are non-rendering (hidden) elements
  const prevIsHidden = isHiddenInput(prevTagName, prevAttrs);
  const nextIsHidden = isHiddenInput(nextTagName, nextAttrs);

  let trimLeft = prevTag && !inlineElementsToKeepWhitespace.has(prevTag);

  // Smart default behavior: Collapse space after non-rendering elements (`type="hidden"`)
  // This happens even in basic `collapseWhitespace` mode (safe optimization)
  if (!trimLeft && prevIsHidden && str && !/\S/.test(str)) {
    trimLeft = true;
  }

  // Aggressive mode: Collapse between all form controls (pure whitespace only)
  const isPureWhitespace = str && !/\S/.test(str);
  if (!trimLeft && prevTagName && nextTagName &&
      options.collapseInlineTagWhitespace &&
      isPureWhitespace &&
      formControlElements.has(prevTagName) && formControlElements.has(nextTagName)) {
    trimLeft = true;
  }

  if (trimLeft && !options.collapseInlineTagWhitespace) {
    trimLeft = prevTag.charAt(0) === '/' ? !inlineElements.has(prevTag.slice(1)) : !inlineTextSet.has(prevTag);
  }

  // When `collapseInlineTagWhitespace` is enabled, still preserve whitespace around inline text elements
  if (trimLeft && options.collapseInlineTagWhitespace) {
    const tagName = prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag;
    if (inlineElementsToKeepWhitespaceWithin.has(tagName)) {
      trimLeft = false;
    }
  }

  let trimRight = nextTag && !inlineElementsToKeepWhitespace.has(nextTag);

  // Smart default behavior: Collapse space before non-rendering elements (`type="hidden"`)
  if (!trimRight && nextIsHidden && str && !/\S/.test(str)) {
    trimRight = true;
  }

  // Aggressive mode: Same as `trimLeft`
  if (!trimRight && prevTagName && nextTagName &&
      options.collapseInlineTagWhitespace &&
      isPureWhitespace &&
      formControlElements.has(prevTagName) && formControlElements.has(nextTagName)) {
    trimRight = true;
  }

  if (trimRight && !options.collapseInlineTagWhitespace) {
    trimRight = nextTag.charAt(0) === '/' ? !inlineTextSet.has(nextTag.slice(1)) : !inlineElements.has(nextTag);
  }

  // When `collapseInlineTagWhitespace` is enabled, still preserve whitespace around inline text elements
  if (trimRight && options.collapseInlineTagWhitespace) {
    const tagName = nextTag.charAt(0) === '/' ? nextTag.slice(1) : nextTag;
    if (inlineElementsToKeepWhitespaceWithin.has(tagName)) {
      trimRight = false;
    }
  }

  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);
}

// Collapse/trim whitespace for given tag

function canCollapseWhitespace(tag) {
  return !/^(?:script|style|pre|textarea)$/.test(tag);
}

function canTrimWhitespace(tag) {
  return !/^(?:pre|textarea)$/.test(tag);
}

// Imports


// CSS processing

// Wrap CSS declarations for inline styles and media queries
// This ensures proper context for CSS minification
function wrapCSS(text, type) {
  switch (type) {
    case 'inline':
      return '*{' + text + '}';
    case 'media':
      return '@media ' + text + '{a{top:0}}';
    default:
      return text;
  }
}

function unwrapCSS(text, type) {
  let matches;
  switch (type) {
    case 'inline':
      matches = text.match(/^\*\{([\s\S]*)\}$/);
      break;
    case 'media':
      matches = text.match(/^@media ([\s\S]*?)\s*{[\s\S]*}$/);
      break;
  }
  return matches ? matches[1] : text;
}

async function cleanConditionalComment(comment, options, minifyHTML) {
  return options.processConditionalComments
    ? await replaceAsync(comment, /^(\[if\s[^\]]+]>)([\s\S]*?)(<!\[endif])$/, async function (match, prefix, text, suffix) {
      return prefix + await minifyHTML(text, options, true) + suffix;
    })
    : comment;
}

// Script processing

function minifyJson(text, options) {
  try {
    return JSON.stringify(JSON.parse(text));
  }
  catch (err) {
    if (!options.continueOnMinifyError) {
      throw err;
    }
    options.log && options.log(err);
    return text;
  }
}

function hasJsonScriptType(attrs) {
  for (let i = 0, len = attrs.length; i < len; i++) {
    const attrName = attrs[i].name.toLowerCase();
    if (attrName === 'type') {
      const attrValue = trimWhitespace((attrs[i].value || '').split(/;/, 2)[0]).toLowerCase();
      if (jsonScriptTypes.has(attrValue)) {
        return true;
      }
    }
  }
  return false;
}

async function processScript(text, options, currentAttrs, minifyHTML) {
  for (let i = 0, len = currentAttrs.length; i < len; i++) {
    const attrName = currentAttrs[i].name.toLowerCase();
    if (attrName === 'type') {
      const rawValue = currentAttrs[i].value;
      const normalizedValue = trimWhitespace((rawValue || '').split(/;/, 2)[0]).toLowerCase();
      // Minify JSON script types automatically
      if (jsonScriptTypes.has(normalizedValue)) {
        return minifyJson(text, options);
      }
      // Process custom script types if specified
      if (options.processScripts && options.processScripts.indexOf(rawValue) > -1) {
        return await minifyHTML(text, options);
      }
    }
  }
  return text;
}

/**
 * Lightweight SVG optimizations:
 * - Numeric precision reduction for coordinates and path data
 * - Whitespace removal in attribute values (numeric sequences)
 * - Default attribute removal (safe, well-documented defaults)
 * - Color minification (hex shortening, rgb() to hex, named colors)
 * - Identity transform removal
 * - Path data space optimization
 */


// Cache for minified numbers
const numberCache = new LRU(100);

/**
 * Named colors that are shorter than their hex equivalents
 * Only includes cases where using the name saves bytes
 */
const NAMED_COLORS = {
  '#f00': 'red',        // #f00 (4) → red (3), saves 1
  '#c0c0c0': 'silver',  // #c0c0c0 (7) → silver (6), saves 1
  '#808080': 'gray',    // #808080 (7) → gray (4), saves 3
  '#800000': 'maroon',  // #800000 (7) → maroon (6), saves 1
  '#808000': 'olive',   // #808000 (7) → olive (5), saves 2
  '#008000': 'green',   // #008000 (7) → green (5), saves 2
  '#800080': 'purple',  // #800080 (7) → purple (6), saves 1
  '#008080': 'teal',    // #008080 (7) → teal (4), saves 3
  '#000080': 'navy',    // #000080 (7) → navy (4), saves 3
  '#ffa500': 'orange'   // #ffa500 (7) → orange (6), saves 1
};

/**
 * Default SVG attribute values that can be safely removed
 * Only includes well-documented, widely-supported defaults
 */
const SVG_DEFAULT_ATTRS = {
  // Fill and stroke defaults
  fill: value => value === 'black' || value === '#000' || value === '#000000',
  'fill-opacity': value => value === '1',
  'fill-rule': value => value === 'nonzero',
  stroke: value => value === 'none',
  'stroke-dasharray': value => value === 'none',
  'stroke-dashoffset': value => value === '0',
  'stroke-linecap': value => value === 'butt',
  'stroke-linejoin': value => value === 'miter',
  'stroke-miterlimit': value => value === '4',
  'stroke-opacity': value => value === '1',
  'stroke-width': value => value === '1',

  // Text and font defaults
  'font-family': value => value === 'inherit',
  'font-size': value => value === 'medium',
  'font-style': value => value === 'normal',
  'font-variant': value => value === 'normal',
  'font-weight': value => value === 'normal',
  'letter-spacing': value => value === 'normal',
  'text-decoration': value => value === 'none',
  'text-anchor': value => value === 'start',

  // Other common defaults
  opacity: value => value === '1',
  visibility: value => value === 'visible',
  display: value => value === 'inline',
  // Note: Overflow handled especially in `isDefaultAttribute` (not safe for root `<svg>`)

  // Clipping and masking defaults
  'clip-rule': value => value === 'nonzero',
  'clip-path': value => value === 'none',
  mask: value => value === 'none',

  // Marker defaults
  'marker-start': value => value === 'none',
  'marker-mid': value => value === 'none',
  'marker-end': value => value === 'none',

  // Filter and color defaults
  filter: value => value === 'none',
  'color-interpolation': value => value === 'sRGB',
  'color-interpolation-filters': value => value === 'linearRGB'
};

/**
 * Minify numeric value by removing trailing zeros and unnecessary decimals
 * @param {string} num - Numeric string to minify
 * @param {number} precision - Maximum decimal places to keep
 * @returns {string} Minified numeric string
 */
function minifyNumber(num, precision = 3) {
  // Fast path for common values (avoids parsing and caching)
  if (num === '0' || num === '1') return num;
  // Common decimal variants that tools export
  if (num === '0.0' || num === '0.00' || num === '0.000') return '0';
  if (num === '1.0' || num === '1.00' || num === '1.000') return '1';

  // Check cache
  // (Note: Uses input string as key, so “0.0000” and “0.00000” create separate entries.
  // This is intentional to avoid parsing overhead.
  // Real-world SVG files from export tools typically use consistent formats.)
  const cacheKey = `${num}:${precision}`;
  const cached = numberCache.get(cacheKey);
  if (cached !== undefined) return cached;

  const parsed = parseFloat(num);

  // Handle special cases
  if (isNaN(parsed)) return num;
  if (parsed === 0) return '0';
  if (!isFinite(parsed)) return num;

  // Convert to fixed precision, then remove trailing zeros
  const fixed = parsed.toFixed(precision);
  const trimmed = fixed.replace(/\.?0+$/, '');

  // Remove leading zero before decimal point (e.g., `0.5` → `.5`, `-0.3` → `-.3`)
  const result = (trimmed || '0').replace(/^(-?)0\./, '$1.');
  numberCache.set(cacheKey, result);
  return result;
}

/**
 * Minify SVG path data by reducing numeric precision and removing unnecessary spaces
 * @param {string} pathData - SVG path data string
 * @param {number} precision - Decimal precision for coordinates
 * @returns {string} Minified path data
 */
function minifyPathData(pathData, precision = 3) {
  if (!pathData || typeof pathData !== 'string') return pathData;

  // First, minify all numbers
  let result = pathData.replace(RE_NUMERIC_VALUE, (match) => {
    return minifyNumber(match, precision);
  });

  // Remove unnecessary spaces around path commands
  // Safe to remove space after a command letter when it’s followed by a number
  // (which may be negative or start with a decimal point)
  // `M 10 20` → `M10 20`, `L -5 -3` → `L-5-3`, `M .5 .3` → `M.5.3`
  result = result.replace(/([MLHVCSQTAZmlhvcsqtaz])\s+(?=-?\.?\d)/g, '$1');

  // Safe to remove space before command letter when preceded by a number
  // `0 L` → `0L`, `20 M` → `20M`, `.5 L` → `.5L`
  result = result.replace(/([\d.])\s+([MLHVCSQTAZmlhvcsqtaz])/g, '$1$2');

  // Safe to remove space before negative number when preceded by a number
  // `10 -20` → `10-20`, `.5 -.3` → `.5-.3` (minus sign is always a separator)
  result = result.replace(/([\d.])\s+(-)/g, '$1$2');

  // Safe to remove space between two decimal numbers (decimal point acts as separator)
  // `.5 .3` → `.5.3` (only when previous char is `.`, indicating a complete decimal)
  // Note: `0 .3` must not become `0.3` (that would change two numbers into one)
  result = result.replace(/(\.\d*)\s+(\.)/g, '$1$2');

  return result;
}

/**
 * Minify whitespace in numeric attribute values
 * Examples:
 * - “10 , 20" → "10,20"
 * - "translate( 10 20 )" → "translate(10 20)"
 * - "100, 10  40,  198" → "100,10 40,198"
 *
 * @param {string} value - Attribute value to minify
 * @returns {string} Minified value
 */
function minifyAttributeWhitespace(value) {
  if (!value || typeof value !== 'string') return value;

  return value
    // Remove spaces around commas
    .replace(/\s*,\s*/g, ',')
    // Remove spaces around parentheses
    .replace(/\(\s+/g, '(')
    .replace(/\s+\)/g, ')')
    // Collapse multiple spaces to single space
    .replace(/\s+/g, ' ')
    // Trim leading/trailing whitespace
    .trim();
}

/**
 * Minify color values (hex shortening, rgb to hex conversion, named colors)
 * Only processes simple color values; preserves case-sensitive references like `url(#id)`
 * @param {string} color - Color value to minify
 * @returns {string} Minified color value
 */
function minifyColor(color) {
  if (!color || typeof color !== 'string') return color;

  const trimmed = color.trim();

  // Don’t process values that aren’t simple colors (preserve case-sensitive references)
  // `url(#id)`, `var(--name)`, `inherit`, `currentColor`, etc.
  if (trimmed.includes('url(') || trimmed.includes('var(') || trimmed === 'inherit' || trimmed === 'currentColor') {
    return trimmed;
  }

  // Now safe to lowercase for color matching
  const lower = trimmed.toLowerCase();

  // Shorten 6-digit hex to 3-digit when possible
  // `#aabbcc` → `#abc`, `#000000` → `#000`
  const hexMatch = lower.match(/^#([0-9a-f]{6})$/);
  if (hexMatch) {
    const hex = hexMatch[1];
    if (hex[0] === hex[1] && hex[2] === hex[3] && hex[4] === hex[5]) {
      const shortened = '#' + hex[0] + hex[2] + hex[4];
      // Try to use named color if shorter
      return NAMED_COLORS[shortened] || shortened;
    }
    // Can’t shorten, but check for named color
    return NAMED_COLORS[lower] || lower;
  }

  // Match 3-digit hex colors
  const hex3Match = lower.match(/^#[0-9a-f]{3}$/);
  if (hex3Match) {
    // Check if there’s a shorter named color
    return NAMED_COLORS[lower] || lower;
  }

  // Convert rgb() to hex
  const rgbMatch = lower.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
  if (rgbMatch) {
    const r = parseInt(rgbMatch[1], 10);
    const g = parseInt(rgbMatch[2], 10);
    const b = parseInt(rgbMatch[3], 10);

    if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
      const toHex = (n) => {
        const h = n.toString(16);
        return h.length === 1 ? '0' + h : h;
      };
      const hexColor = '#' + toHex(r) + toHex(g) + toHex(b);

      // Try to shorten if possible
      if (hexColor[1] === hexColor[2] && hexColor[3] === hexColor[4] && hexColor[5] === hexColor[6]) {
        const shortened = '#' + hexColor[1] + hexColor[3] + hexColor[5];
        return NAMED_COLORS[shortened] || shortened;
      }
      return NAMED_COLORS[hexColor] || hexColor;
    }
  }

  // Not a recognized color format, return as-is (preserves case)
  return trimmed;
}

// Attributes that contain numeric sequences or path data
const NUMERIC_ATTRS = new Set([
  'd', // Path data
  'points', // Polygon/polyline points
  'viewBox', // `viewBox` coordinates
  'transform', // Transform functions
  'x', 'y', 'x1', 'y1', 'x2', 'y2', // Coordinates
  'cx', 'cy', 'r', 'rx', 'ry', // Circle/ellipse
  'width', 'height', // Dimensions
  'dx', 'dy', // Text offsets
  'offset', // Gradient offset
  'startOffset', // `textPath`
  'pathLength', // Path length
  'stdDeviation', // Filter params
  'baseFrequency', // Turbulence
  'k1', 'k2', 'k3', 'k4' // Composite filter
]);

// Attributes that contain color values
const COLOR_ATTRS = new Set([
  'fill',
  'stroke',
  'stop-color',
  'flood-color',
  'lighting-color'
]);

// Pre-compiled regexes for identity transform detection (compiled once at module load)
// Separator pattern: Accepts comma with optional spaces or one or more spaces
const SEP = '(?:\\s*,\\s*|\\s+)';

// `translate(0)`, `translate(0,0)`, `translate(0 0)` (matches 0, 0.0, 0.00, etc.)
const IDENTITY_TRANSLATE_RE = new RegExp(`^translate\\s*\\(\\s*0(?:\\.0+)?\\s*(?:${SEP}0(?:\\.0+)?\\s*)?\\)$`, 'i');

// `scale(1)`, `scale(1,1)`, `scale(1 1)` (matches 1, 1.0, 1.00, etc.)
const IDENTITY_SCALE_RE = new RegExp(`^scale\\s*\\(\\s*1(?:\\.0+)?\\s*(?:${SEP}1(?:\\.0+)?\\s*)?\\)$`, 'i');

// `rotate(0)`, `rotate(0 cx cy)`, `rotate(0, cx, cy)` (matches 0, 0.0, 0.00, etc.)
// Note: `cx` and `cy` must be valid numbers if present
const IDENTITY_ROTATE_RE = new RegExp(`^rotate\\s*\\(\\s*0(?:\\.0+)?\\s*(?:${SEP}-?\\d+(?:\\.\\d+)?${SEP}-?\\d+(?:\\.\\d+)?)?\\s*\\)$`, 'i');

// `skewX(0)`, `skewY(0)` (matches 0, 0.0, 0.00, etc.)
const IDENTITY_SKEW_RE = /^skew[XY]\s*\(\s*0(?:\.0+)?\s*\)$/i;

// `matrix(1,0,0,1,0,0)`, `matrix(1 0 0 1 0 0)`—identity matrix (matches 1.0/0.0 variants)
const IDENTITY_MATRIX_RE = new RegExp(`^matrix\\s*\\(\\s*1(?:\\.0+)?\\s*${SEP}0(?:\\.0+)?\\s*${SEP}0(?:\\.0+)?\\s*${SEP}1(?:\\.0+)?\\s*${SEP}0(?:\\.0+)?\\s*${SEP}0(?:\\.0+)?\\s*\\)$`, 'i');

/**
 * Check if a transform attribute has no effect (identity transform)
 * @param {string} transform - Transform attribute value
 * @returns {boolean} True if transform is an identity (has no effect)
 */
function isIdentityTransform(transform) {
  if (!transform || typeof transform !== 'string') return false;

  const trimmed = transform.trim();

  // Check for common identity transforms using pre-compiled regexes
  return IDENTITY_TRANSLATE_RE.test(trimmed) ||
         IDENTITY_SCALE_RE.test(trimmed) ||
         IDENTITY_ROTATE_RE.test(trimmed) ||
         IDENTITY_SKEW_RE.test(trimmed) ||
         IDENTITY_MATRIX_RE.test(trimmed);
}

/**
 * Check if an attribute should be removed based on default value
 * @param {string} tag - Element tag name (e.g., `svg`, `rect`, `path`)
 * @param {string} name - Attribute name
 * @param {string} value - Attribute value
 * @returns {boolean} True if attribute can be removed
 */
function isDefaultAttribute(tag, name, value) {
  // Special case: `overflow="visible"` is unsafe for root `<svg>` element
  // Root SVG may need explicit `overflow="visible"` to show clipped content
  if (name === 'overflow' && value === 'visible') {
    return tag !== 'svg'; // Only remove for non-root SVG elements
  }

  const checker = SVG_DEFAULT_ATTRS[name];
  if (!checker) return false;

  // Special case: Don’t remove `fill="black"` if stroke exists without fill
  // This would change the rendering (stroke-only shapes would gain black fill)
  if (name === 'fill' && checker(value)) {
    // This check would require looking at other attributes on the same element
    // For safety, we’ll keep this conservative and not remove `fill="black"`
    // in the initial implementation. Can be refined later.
    return false;
  }

  return checker(value);
}

/**
 * Minify SVG attribute value based on attribute name
 * @param {string} name - Attribute name
 * @param {string} value - Attribute value
 * @param {Object} options - Minification options
 * @returns {string} Minified attribute value
 */
function minifySVGAttributeValue(name, value, options = {}) {
  if (!value || typeof value !== 'string') return value;

  const { precision = 3, minifyColors = true } = options;

  // Path data gets special treatment
  if (name === 'd') {
    return minifyPathData(value, precision);
  }

  // Numeric attributes get precision reduction and whitespace minification
  if (NUMERIC_ATTRS.has(name)) {
    const minified = value.replace(RE_NUMERIC_VALUE, (match) => {
      return minifyNumber(match, precision);
    });
    return minifyAttributeWhitespace(minified);
  }

  // Color attributes get color minification
  if (minifyColors && COLOR_ATTRS.has(name)) {
    return minifyColor(value);
  }

  return value;
}

/**
 * Check if an SVG attribute can be removed
 * @param {string} tag - Element tag name (e.g., `svg`, `rect`, `path`)
 * @param {string} name - Attribute name
 * @param {string} value - Attribute value
 * @param {Object} options - Minification options
 * @returns {boolean} True if attribute should be removed
 */
function shouldRemoveSVGAttribute(tag, name, value, options = {}) {
  const { removeDefaults = true } = options;

  if (!removeDefaults) return false;

  // Check for identity transforms
  if (name === 'transform' && isIdentityTransform(value)) {
    return true;
  }

  return isDefaultAttribute(tag, name, value);
}

/**
 * Get default SVG minification options
 * @param {Object} userOptions - User-provided options
 * @returns {Object} Complete options object with defaults
 */
function getSVGMinifierOptions(userOptions) {
  if (typeof userOptions === 'boolean') {
    return userOptions ? {
      precision: 3,
      removeDefaults: true,
      minifyColors: true
    } : null;
  }

  if (typeof userOptions === 'object' && userOptions !== null) {
    return {
      precision: userOptions.precision ?? 3,
      removeDefaults: userOptions.removeDefaults ?? true,
      minifyColors: userOptions.minifyColors ?? true
    };
  }

  return null;
}

// Imports


// Helper functions

function shouldMinifyInnerHTML(options) {
  return Boolean(
    options.collapseWhitespace ||
    options.removeComments ||
    options.removeOptionalTags ||
    options.minifyJS !== identity ||
    options.minifyCSS !== identityAsync ||
    options.minifyURLs !== identity ||
    options.minifySVG
  );
}

// Main options processor

/**
 * @param {Partial<MinifierOptions>} inputOptions - User-provided options
 * @param {Object} deps - Dependencies from htmlminifier.js
 * @param {Function} deps.getLightningCSS - Function to lazily load Lightning CSS
 * @param {Function} deps.getTerser - Function to lazily load Terser
 * @param {Function} deps.getSwc - Function to lazily load @swc/core
 * @param {LRU} deps.cssMinifyCache - CSS minification cache
 * @param {LRU} deps.jsMinifyCache - JS minification cache
 * @returns {MinifierOptions} Normalized options with defaults applied
 */
const processOptions = (inputOptions, { getLightningCSS, getTerser, getSwc, cssMinifyCache, jsMinifyCache } = {}) => {
  const options = {
    name: function (name) {
      return name.toLowerCase();
    },
    canCollapseWhitespace,
    canTrimWhitespace,
    continueOnMinifyError: true,
    html5: true,
    ignoreCustomComments: [
      /^!/,
      /^\s*#/
    ],
    ignoreCustomFragments: [
      /<%[\s\S]*?%>/,
      /<\?[\s\S]*?\?>/
    ],
    includeAutoGeneratedTags: true,
    log: identity,
    minifyCSS: identityAsync,
    minifyJS: identity,
    minifyURLs: identity,
    minifySVG: null
  };

  // Helper to convert string patterns to RegExp (for JSON config support)
  const parseRegExp = (value) => {
    if (typeof value === 'string') {
      return new RegExp(value.replace(/^\/(.*)\/$/, '$1'));
    }
    return value; // Already a RegExp or another type
  };

  const parseRegExpArray = (arr) => {
    return Array.isArray(arr) ? arr.map(parseRegExp) : arr;
  };

  // Helper for nested arrays (e.g., `customAttrSurround: [[start, end], …]`)
  const parseNestedRegExpArray = (arr) => {
    if (!Array.isArray(arr)) return arr;
    return arr.map(item => {
      // If item is an array (a pair), recursively convert each element
      if (Array.isArray(item)) {
        return item.map(parseRegExp);
      }
      // Otherwise, convert single item
      return parseRegExp(item);
    });
  };

  // Apply preset first if specified (so user options can override preset values)
  if (inputOptions.preset) {
    const preset = getPreset(inputOptions.preset);
    if (preset) {
      Object.assign(options, preset);
    } else {
      const available = getPresetNames().join(', ');
      console.warn(`HTML Minifier Next: Unknown preset “${inputOptions.preset}”. Available presets: ${available}`);
    }
  }

  Object.keys(inputOptions).forEach(function (key) {
    const option = inputOptions[key];

    // Skip preset key—it’s already been processed
    if (key === 'preset') {
      return;
    }

    if (key === 'caseSensitive') {
      if (option) {
        options.name = identity;
      }
    } else if (key === 'log') {
      if (typeof option === 'function') {
        options.log = option;
      }
    } else if (key === 'minifyCSS' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      const lightningCssOptions = typeof option === 'object' ? option : {};

      options.minifyCSS = async function (text, type) {
        // Fast path: Nothing to minify
        if (!text || !text.trim()) {
          return text;
        }

        // Optimization: Only process URLs if minification is enabled (not identity function)
        // This avoids expensive `replaceAsync` when URL minification is disabled
        if (options.minifyURLs !== identity) {
          text = await replaceAsync(
            text,
            /(url\s*\(\s*)(?:"([^"]*)"|'([^']*)'|([^\s)]+))(\s*\))/ig,
            async function (match, prefix, dq, sq, unq, suffix) {
              const quote = dq != null ? '"' : (sq != null ? "'" : '');
              const url = dq ?? sq ?? unq ?? '';
              try {
                const out = await options.minifyURLs(url);
                return prefix + quote + (typeof out === 'string' ? out : url) + quote + suffix;
              } catch (err) {
                if (!options.continueOnMinifyError) {
                  throw err;
                }
                options.log && options.log(err);
                return match;
              }
            }
          );
        }

        // Cache key: Wrapped content, type, options signature
        const inputCSS = wrapCSS(text, type);
        const cssSig = stableStringify({ type, opts: lightningCssOptions, cont: !!options.continueOnMinifyError });
        // For large inputs, use length and content fingerprint (first/last 50 chars) to prevent collisions
        const cssKey = inputCSS.length > 2048
          ? (inputCSS.length + '|' + inputCSS.slice(0, 50) + inputCSS.slice(-50) + '|' + type + '|' + cssSig)
          : (inputCSS + '|' + type + '|' + cssSig);

        try {
          const cached = cssMinifyCache.get(cssKey);
          if (cached) {
            // Support both resolved values and in-flight promises
            return await cached;
          }

          // In-flight promise caching: Prevent duplicate concurrent minifications
          // of the same CSS content (same pattern as JS minification)
          const inFlight = (async () => {
            const transformCSS = await getLightningCSS();
            // Note: `Buffer.from()` is required—Lightning CSS API expects Uint8Array
            const result = transformCSS({
              filename: 'input.css',
              code: Buffer.from(inputCSS),
              minify: true,
              errorRecovery: !!options.continueOnMinifyError,
              ...lightningCssOptions
            });

            const outputCSS = unwrapCSS(result.code.toString(), type);

            // If Lightning CSS removed significant content that looks like template syntax or UIDs, return original
            // This preserves:
            // 1. Template code like `<?php ?>`, `<%= ?>`, `{{ }}`, etc. (contain `<` or `>` but not `CDATA`)
            // 2. UIDs representing custom fragments (only lowercase letters and digits, no spaces)
            // CDATA sections, HTML entities, and other invalid CSS are allowed to be removed
            const isCDATA = text.includes('<![CDATA[');
            const uidPattern = /[a-z0-9]{10,}/; // UIDs are long alphanumeric strings
            const hasUID = uidPattern.test(text) && !isCDATA; // Exclude CDATA from UID detection
            const looksLikeTemplate = (text.includes('<') || text.includes('>')) && !isCDATA;

            // Preserve if output is empty and input had template syntax or UIDs
            // This catches cases where Lightning CSS removed content that should be preserved
            return (text.trim() && !outputCSS.trim() && (looksLikeTemplate || hasUID)) ? text : outputCSS;
          })();

          cssMinifyCache.set(cssKey, inFlight);
          const resolved = await inFlight;
          cssMinifyCache.set(cssKey, resolved);
          return resolved;
        } catch (err) {
          cssMinifyCache.delete(cssKey);
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else if (key === 'minifyJS' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      // Parse configuration
      const config = typeof option === 'object' ? option : {};
      const engine = (config.engine || 'terser').toLowerCase();

      // Validate engine
      const supportedEngines = ['terser', 'swc'];
      if (!supportedEngines.includes(engine)) {
        throw new Error(`Unsupported JS minifier engine: “${engine}”. Supported engines: ${supportedEngines.join(', ')}`);
      }

      // Extract engine-specific options (excluding `engine` field itself)
      const engineOptions = { ...config };
      delete engineOptions.engine;

      // Terser options (needed for inline JS and when engine is `terser`)
      const terserOptions = engine === 'terser' ? engineOptions : {};
      terserOptions.parse = {
        ...terserOptions.parse,
        bare_returns: false
      };

      // SWC options (when engine is `swc`)
      const swcOptions = engine === 'swc' ? engineOptions : {};

      // Pre-compute option signatures once for performance (avoid repeated stringification)
      const terserSig = stableStringify({
        ...terserOptions,
        cont: !!options.continueOnMinifyError
      });
      const swcSig = stableStringify({
        ...swcOptions,
        cont: !!options.continueOnMinifyError
      });

      options.minifyJS = async function (text, inline) {
        const start = text.match(/^\s*<!--.*/);
        const code = start ? text.slice(start[0].length).replace(/\n\s*-->\s*$/, '') : text;

        // Fast path: Avoid invoking minifier for empty/whitespace-only content
        if (!code || !code.trim()) {
          return '';
        }

        // Hybrid strategy: Always use Terser for inline JS (needs bare returns support)
        // Use user’s chosen engine for script blocks
        const useEngine = inline ? 'terser' : engine;

        let jsKey;
        try {
          // Select pre-computed signature based on engine
          const optsSig = useEngine === 'terser' ? terserSig : swcSig;

          // For large inputs, use length and content fingerprint to prevent collisions
          jsKey = (code.length > 2048 ? (code.length + '|' + code.slice(0, 50) + code.slice(-50) + '|') : (code + '|'))
            + (inline ? '1' : '0') + '|' + useEngine + '|' + optsSig;

          const cached = jsMinifyCache.get(jsKey);
          if (cached) {
            return await cached;
          }

          const inFlight = (async () => {
            // Dispatch to appropriate minifier
            if (useEngine === 'terser') {
              // Create a copy to avoid mutating shared `terserOptions` (race condition)
              const terserCallOptions = {
                ...terserOptions,
                parse: {
                  ...terserOptions.parse,
                  bare_returns: inline
                }
              };
              const terser = await getTerser();
              const result = await terser(code, terserCallOptions);
              return result.code.replace(RE_TRAILING_SEMICOLON, '');
            } else if (useEngine === 'swc') {
              const swc = await getSwc();
              // `swc.minify()` takes compress and mangle directly as options
              const result = await swc.minify(code, {
                compress: true,
                mangle: true,
                ...swcOptions, // User options override defaults
              });
              return result.code.replace(RE_TRAILING_SEMICOLON, '');
            }
            throw new Error(`Unknown JS minifier engine: ${useEngine}`);
          })();

          jsMinifyCache.set(jsKey, inFlight);
          const resolved = await inFlight;
          jsMinifyCache.set(jsKey, resolved);
          return resolved;
        } catch (err) {
          if (jsKey) jsMinifyCache.delete(jsKey);
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else if (key === 'minifyURLs' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      let relateUrlOptions = option;

      if (typeof option === 'string') {
        relateUrlOptions = { site: option };
      } else if (typeof option !== 'object') {
        relateUrlOptions = {};
      }

      // Cache relateurl instance for reuse (expensive to create)
      const relateUrlInstance = new RelateURL(relateUrlOptions.site || '', relateUrlOptions);

      // Create instance-specific cache (results depend on site configuration)
      const instanceCache = new LRU(500);

      options.minifyURLs = function (text) {
        // Fast-path: Skip if text doesn’t look like a URL that needs processing
        // Only process if contains URL-like characters (`/`, `:`, `#`, `?`) or spaces that need encoding
        if (!/[/:?#\s]/.test(text)) {
          return text;
        }

        // Check cache
        const cached = instanceCache.get(text);
        if (cached !== undefined) {
          return cached;
        }

        try {
          const result = relateUrlInstance.relate(text);
          instanceCache.set(text, result);
          return result;
        } catch (err) {
          // Don’t cache errors
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else if (key === 'minifySVG') {
      // Process SVG minification options
      // Unlike `minifyCSS`/`minifyJS`, this is a simple options object, not a function
      // The actual minification is applied inline during attribute processing
      options.minifySVG = getSVGMinifierOptions(option);
    } else if (key === 'customAttrCollapse') {
      // Single regex pattern
      options[key] = parseRegExp(option);
    } else if (key === 'customAttrSurround') {
      // Nested array of RegExp pairs: `[[openRegExp, closeRegExp], …]`
      options[key] = parseNestedRegExpArray(option);
    } else if (['customAttrAssign', 'customEventAttributes', 'ignoreCustomComments', 'ignoreCustomFragments'].includes(key)) {
      // Array of regex patterns
      options[key] = parseRegExpArray(option);
    } else {
      options[key] = option;
    }
  });
  return options;
};

// Imports


// Validators

function isConditionalComment(text) {
  return RE_CONDITIONAL_COMMENT.test(text);
}

function isIgnoredComment(text, options) {
  for (let i = 0, len = options.ignoreCustomComments.length; i < len; i++) {
    if (options.ignoreCustomComments[i].test(text)) {
      return true;
    }
  }
  return false;
}

function isEventAttribute(attrName, options) {
  const patterns = options.customEventAttributes;
  if (patterns) {
    for (let i = patterns.length; i--;) {
      if (patterns[i].test(attrName)) {
        return true;
      }
    }
    return false;
  }
  return RE_EVENT_ATTR_DEFAULT.test(attrName);
}

function canRemoveAttributeQuotes(value) {
  // https://mathiasbynens.be/notes/unquoted-attribute-values
  return RE_CAN_REMOVE_ATTR_QUOTES.test(value);
}

function attributesInclude(attributes, attribute) {
  for (let i = attributes.length; i--;) {
    if (attributes[i].name.toLowerCase() === attribute) {
      return true;
    }
  }
  return false;
}

function isAttributeRedundant(tag, attrName, attrValue, attrs) {
  // Fast-path: Check if this element–attribute combination can possibly be redundant
  // before doing expensive string operations

  // Check if attribute name is in general defaults
  const hasGeneralDefault = attrName in generalDefaults;

  // Check if element has any default attributes
  const tagHasDefaults = tag in tagDefaults;

  // Check for legacy attribute rules (element- and attribute-specific)
  const isLegacyAttr = (tag === 'script' && (attrName === 'language' || attrName === 'charset')) || (tag === 'a' && attrName === 'name');

  // If none of these conditions apply, attribute cannot be redundant
  if (!hasGeneralDefault && !tagHasDefaults && !isLegacyAttr) {
    return false;
  }

  // Now we know we need to check the value, so normalize it
  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : '';

  // Legacy attribute checks
  if (tag === 'script' && attrName === 'language' && attrValue === 'javascript') {
    return true;
  }
  if (tag === 'script' && attrName === 'charset' && !attributesInclude(attrs, 'src')) {
    return true;
  }
  if (tag === 'a' && attrName === 'name' && attributesInclude(attrs, 'id')) {
    return true;
  }

  // Check general defaults
  if (hasGeneralDefault && generalDefaults[attrName] === attrValue) {
    return true;
  }

  // Check tag-specific defaults
  return tagHasDefaults && tagDefaults[tag][attrName] === attrValue;
}

function isScriptTypeAttribute(attrValue = '') {
  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();
  return attrValue === '' || executableScriptsMimetypes.has(attrValue);
}

function keepScriptTypeAttribute(attrValue = '') {
  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();
  return keepScriptsMimetypes.has(attrValue);
}

function isExecutableScript(tag, attrs) {
  if (tag !== 'script') {
    return false;
  }
  for (let i = 0, len = attrs.length; i < len; i++) {
    const attrName = attrs[i].name.toLowerCase();
    if (attrName === 'type') {
      return isScriptTypeAttribute(attrs[i].value);
    }
  }
  return true;
}

function isStyleLinkTypeAttribute(attrValue = '') {
  attrValue = trimWhitespace(attrValue).toLowerCase();
  return attrValue === '' || attrValue === 'text/css';
}

function isStyleElement(tag, attrs) {
  if (tag !== 'style') {
    return false;
  }
  for (let i = 0, len = attrs.length; i < len; i++) {
    const attrName = attrs[i].name.toLowerCase();
    if (attrName === 'type') {
      return isStyleLinkTypeAttribute(attrs[i].value);
    }
  }
  return true;
}

function isBooleanAttribute(attrName, attrValue) {
  return isSimpleBoolean.has(attrName) ||
    (attrName === 'draggable' && !isBooleanValue.has(attrValue)) ||
    (attrValue === '' && emptyCollapsible.has(attrName));
}

function isUriTypeAttribute(attrName, tag) {
  return (
    (/^(?:a|area|link|base)$/.test(tag) && attrName === 'href') ||
    (tag === 'img' && /^(?:src|longdesc|usemap)$/.test(attrName)) ||
    (tag === 'object' && /^(?:classid|codebase|data|usemap)$/.test(attrName)) ||
    (tag === 'q' && attrName === 'cite') ||
    (tag === 'blockquote' && attrName === 'cite') ||
    ((tag === 'ins' || tag === 'del') && attrName === 'cite') ||
    (tag === 'form' && attrName === 'action') ||
    (tag === 'input' && (attrName === 'src' || attrName === 'usemap')) ||
    (tag === 'head' && attrName === 'profile') ||
    (tag === 'script' && (attrName === 'src' || attrName === 'for'))
  );
}

function isNumberTypeAttribute(attrName, tag) {
  return (
    (/^(?:a|area|object|button)$/.test(tag) && attrName === 'tabindex') ||
    (tag === 'input' && (attrName === 'maxlength' || attrName === 'tabindex')) ||
    (tag === 'select' && (attrName === 'size' || attrName === 'tabindex')) ||
    (tag === 'textarea' && /^(?:rows|cols|tabindex)$/.test(attrName)) ||
    (tag === 'colgroup' && attrName === 'span') ||
    (tag === 'col' && attrName === 'span') ||
    ((tag === 'th' || tag === 'td') && (attrName === 'rowspan' || attrName === 'colspan'))
  );
}

function isLinkType(tag, attrs, value) {
  if (tag !== 'link') return false;
  const needle = String(value).toLowerCase();
  for (let i = 0; i < attrs.length; i++) {
    if (attrs[i].name.toLowerCase() === 'rel') {
      const tokens = String(attrs[i].value).toLowerCase().split(/\s+/);
      if (tokens.includes(needle)) return true;
    }
  }
  return false;
}

function isMediaQuery(tag, attrs, attrName) {
  return attrName === 'media' && (isLinkType(tag, attrs, 'stylesheet') || isStyleElement(tag, attrs));
}

function isSrcset(attrName, tag) {
  return attrName === 'srcset' && srcsetElements.has(tag);
}

function isMetaViewport(tag, attrs) {
  if (tag !== 'meta') {
    return false;
  }
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i].name.toLowerCase() === 'name' && attrs[i].value.toLowerCase() === 'viewport') {
      return true;
    }
  }
  return false;
}

function isContentSecurityPolicy(tag, attrs) {
  if (tag !== 'meta') {
    return false;
  }
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i].name.toLowerCase() === 'http-equiv' && attrs[i].value.toLowerCase() === 'content-security-policy') {
      return true;
    }
  }
  return false;
}

function canDeleteEmptyAttribute(tag, attrName, attrValue, options) {
  const isValueEmpty = !attrValue || attrValue.trim() === '';
  if (!isValueEmpty) {
    return false;
  }
  if (typeof options.removeEmptyAttributes === 'function') {
    return options.removeEmptyAttributes(attrName, tag);
  }
  return (tag === 'input' && attrName === 'value') || reEmptyAttribute.test(attrName);
}

function hasAttrName(name, attrs) {
  for (let i = attrs.length - 1; i >= 0; i--) {
    if (attrs[i].name === name) {
      return true;
    }
  }
  return false;
}

// Cleaners

async function cleanAttributeValue(tag, attrName, attrValue, options, attrs, minifyHTMLSelf) {
  // Apply early whitespace normalization if enabled
  // Preserves special spaces (no-break space, hair space, etc.) for consistency with `collapseWhitespace`
  if (options.collapseAttributeWhitespace) {
    // Fast path: Only process if whitespace exists (avoids regex overhead on clean values)
    if (RE_ATTR_WS_CHECK.test(attrValue)) {
      // Two-pass approach (faster than single-pass with callback)
      // First: Collapse internal whitespace sequences to single space
      // Second: Trim leading/trailing whitespace
      attrValue = attrValue.replace(RE_ATTR_WS_COLLAPSE, ' ').replace(RE_ATTR_WS_TRIM, '');
    }
  }

  if (isEventAttribute(attrName, options)) {
    attrValue = trimWhitespace(attrValue).replace(/^javascript:\s*/i, '');
    try {
      return await options.minifyJS(attrValue, true);
    } catch (err) {
      if (!options.continueOnMinifyError) {
        throw err;
      }
      options.log && options.log(err);
      return attrValue;
    }
  } else if (attrName === 'class') {
    attrValue = trimWhitespace(attrValue);
    if (options.sortClassName) {
      attrValue = options.sortClassName(attrValue);
    } else {
      attrValue = collapseWhitespaceAll(attrValue);
    }
    return attrValue;
  } else if (isUriTypeAttribute(attrName, tag)) {
    attrValue = trimWhitespace(attrValue);
    if (isLinkType(tag, attrs, 'canonical')) {
      return attrValue;
    }
    try {
      const out = await options.minifyURLs(attrValue);
      return typeof out === 'string' ? out : attrValue;
    } catch (err) {
      if (!options.continueOnMinifyError) {
        throw err;
      }
      options.log && options.log(err);
      return attrValue;
    }
  } else if (isNumberTypeAttribute(attrName, tag)) {
    return trimWhitespace(attrValue);
  } else if (attrName === 'style') {
    attrValue = trimWhitespace(attrValue);
    if (attrValue) {
      if (attrValue.endsWith(';') && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {
        attrValue = attrValue.replace(/\s*;$/, ';');
      }
      try {
        attrValue = await options.minifyCSS(attrValue, 'inline');
        // After minification, check if CSS consists entirely of invalid properties (no values)
        // I.e., `color:` or `margin:;padding:` should be treated as empty
        if (attrValue && /^(?:[a-z-]+:\s*;?\s*)+$/i.test(attrValue)) {
          attrValue = '';
        }
      } catch (err) {
        if (!options.continueOnMinifyError) {
          throw err;
        }
        options.log && options.log(err);
      }
    }
    return attrValue;
  } else if (isSrcset(attrName, tag)) {
    // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-img-srcset
    attrValue = (await Promise.all(trimWhitespace(attrValue).split(/\s*,\s*/).map(async function (candidate) {
      let url = candidate;
      let descriptor = '';
      const match = candidate.match(/\s+([1-9][0-9]*w|[0-9]+(?:\.[0-9]+)?x)$/);
      if (match) {
        url = url.slice(0, -match[0].length);
        const num = +match[1].slice(0, -1);
        const suffix = match[1].slice(-1);
        if (num !== 1 || suffix !== 'x') {
          descriptor = ' ' + num + suffix;
        }
      }
      try {
        const out = await options.minifyURLs(url);
        return (typeof out === 'string' ? out : url) + descriptor;
      } catch (err) {
        if (!options.continueOnMinifyError) {
          throw err;
        }
        options.log && options.log(err);
        return url + descriptor;
      }
    }))).join(', ');
  } else if (isMetaViewport(tag, attrs) && attrName === 'content') {
    attrValue = attrValue.replace(/\s+/g, '').replace(/[0-9]+\.[0-9]+/g, function (numString) {
      // 0.90000 → 0.9
      // 1.0 → 1
      // 1.0001 → 1.0001 (unchanged)
      return (+numString).toString();
    });
  } else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === 'content') {
    return collapseWhitespaceAll(attrValue);
  } else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {
    attrValue = trimWhitespace(attrValue.replace(/ ?[\n\r]+ ?/g, '').replace(/\s{2,}/g, options.conservativeCollapse ? ' ' : ''));
  } else if (tag === 'script' && attrName === 'type') {
    attrValue = trimWhitespace(attrValue.replace(/\s*;\s*/g, ';'));
  } else if (isMediaQuery(tag, attrs, attrName)) {
    attrValue = trimWhitespace(attrValue);
    // Only minify actual media queries (those with features in parentheses)
    // Skip simple media types like `all`, `screen`, `print` which are already minimal
    if (!/[()]/.test(attrValue)) {
      return attrValue;
    }
    try {
      return await options.minifyCSS(attrValue, 'media');
    } catch (err) {
      if (!options.continueOnMinifyError) {
        throw err;
      }
      options.log && options.log(err);
      return attrValue;
    }
  } else if (tag === 'iframe' && attrName === 'srcdoc') {
    // Recursively minify HTML content within `srcdoc` attribute
    // Fast-path: Skip if nothing would change
    if (!shouldMinifyInnerHTML(options)) {
      return attrValue;
    }
    return minifyHTMLSelf(attrValue, options, true);
  } else if (options.insideSVG && options.minifySVG) {
    // Apply SVG-specific attribute minification when inside SVG elements
    try {
      return minifySVGAttributeValue(attrName, attrValue, options.minifySVG);
    } catch (err) {
      if (!options.continueOnMinifyError) {
        throw err;
      }
      options.log && options.log(err);
      return attrValue;
    }
  }
  return attrValue;
}

/**
 * Choose appropriate quote character for an attribute value
 * @param {string} attrValue - The attribute value
 * @param {Object} options - Minifier options
 * @returns {string} The chosen quote character (`"` or `'`)
 */
function chooseAttributeQuote(attrValue, options) {
  if (typeof options.quoteCharacter !== 'undefined') {
    return options.quoteCharacter === '\'' ? '\'' : '"';
  }

  // Count quotes in a single pass
  let apos = 0, quot = 0;
  for (let i = 0; i < attrValue.length; i++) {
    if (attrValue[i] === "'") apos++;
    else if (attrValue[i] === '"') quot++;
  }
  return apos < quot ? '\'' : '"';
}

async function normalizeAttr(attr, attrs, tag, options, minifyHTML) {
  const attrName = options.name(attr.name);
  let attrValue = attr.value;

  if (options.decodeEntities && attrValue) {
    // Fast path: Only decode when entities are present
    if (attrValue.indexOf('&') !== -1) {
      attrValue = entities.decodeHTMLStrict(attrValue);
    }
  }

  if ((options.removeRedundantAttributes &&
       isAttributeRedundant(tag, attrName, attrValue, attrs)) ||
      (options.removeScriptTypeAttributes && tag === 'script' &&
       attrName === 'type' && isScriptTypeAttribute(attrValue) && !keepScriptTypeAttribute(attrValue)) ||
      (options.removeStyleLinkTypeAttributes && (tag === 'style' || tag === 'link') &&
       attrName === 'type' && isStyleLinkTypeAttribute(attrValue)) ||
      (options.insideSVG && options.minifySVG &&
       shouldRemoveSVGAttribute(tag, attrName, attrValue, options.minifySVG))) {
    return;
  }

  if (attrValue) {
    attrValue = await cleanAttributeValue(tag, attrName, attrValue, options, attrs, minifyHTML);
  }

  if (options.removeEmptyAttributes &&
      canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {
    return;
  }

  if (options.decodeEntities && attrValue && attrValue.indexOf('&') !== -1) {
    attrValue = attrValue.replace(RE_AMP_ENTITY, '&amp;$1');
  }

  return {
    attr,
    name: attrName,
    value: attrValue
  };
}

function buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr) {
  const attrName = normalized.name;
  let attrValue = normalized.value;
  const attr = normalized.attr;
  let attrQuote = attr.quote;
  let attrFragment;
  let emittedAttrValue;

  // Determine if we need to add/keep quotes
  const shouldAddQuotes = typeof attrValue !== 'undefined' && (
    // If `removeAttributeQuotes` is enabled, add quotes only if they can’t be removed
    (options.removeAttributeQuotes && (attrValue.indexOf(uidAttr) !== -1 || !canRemoveAttributeQuotes(attrValue))) ||
    // If `removeAttributeQuotes` is not enabled, preserve original quote style or add quotes if value requires them
    (!options.removeAttributeQuotes && (attrQuote !== '' || !canRemoveAttributeQuotes(attrValue) ||
      // Special case: With `removeTagWhitespace`, unquoted values that aren’t last will have space added,
      // which can create ambiguous/invalid HTML—add quotes to be safe
      (options.removeTagWhitespace && attrQuote === '' && !isLast)))
  );

  if (shouldAddQuotes) {
    // Determine the appropriate quote character
    if (!options.preventAttributesEscaping) {
      // Normal mode: Choose optimal quote type to minimize escaping
      // unless we’re preserving original quotes and they don’t need escaping
      const needsEscaping = (attrQuote === '"' && attrValue.indexOf('"') !== -1) || (attrQuote === "'" && attrValue.indexOf("'") !== -1);

      if (options.removeAttributeQuotes || typeof options.quoteCharacter !== 'undefined' || needsEscaping || attrQuote === '') {
        attrQuote = chooseAttributeQuote(attrValue, options);
      }

      if (attrQuote === '"') {
        attrValue = attrValue.replace(/"/g, '&#34;');
      } else {
        attrValue = attrValue.replace(/'/g, '&#39;');
      }
    } else {
      // `preventAttributesEscaping` mode: Choose safe quotes but don't escape
      // except when both quote types are present—then escape to prevent invalid HTML
      const hasDoubleQuote = attrValue.indexOf('"') !== -1;
      const hasSingleQuote = attrValue.indexOf("'") !== -1;

      // Both quote types present: Escaping is required to guarantee valid HTML delimiter matching
      if (hasDoubleQuote && hasSingleQuote) {
        attrQuote = chooseAttributeQuote(attrValue, options);
        if (attrQuote === '"') {
          attrValue = attrValue.replace(/"/g, '&#34;');
        } else {
          attrValue = attrValue.replace(/'/g, '&#39;');
        }
      // Auto quote selection: Prefer the opposite quote type when value contains one quote type, default to double quotes when none present
      } else if (typeof options.quoteCharacter === 'undefined') {
        if (attrQuote === '"' && hasDoubleQuote && !hasSingleQuote) {
          attrQuote = "'";
        } else if (attrQuote === "'" && hasSingleQuote && !hasDoubleQuote) {
          attrQuote = '"';
        // If no quote character yet (empty string), choose based on content
        } else if (attrQuote === '') {
          if (hasSingleQuote && !hasDoubleQuote) {
            attrQuote = '"';
          } else if (hasDoubleQuote && !hasSingleQuote) {
            attrQuote = "'";
          } else {
            attrQuote = '"';
          }
        // Fallback for invalid/unsupported attrQuote values (not `"`, `'`, or empty string):
        // Choose safe default based on value content
        } else if (attrQuote !== '"' && attrQuote !== "'") {
          if (hasSingleQuote && !hasDoubleQuote) {
            attrQuote = '"';
          } else if (hasDoubleQuote && !hasSingleQuote) {
            attrQuote = "'";
          } else {
            attrQuote = '"';
          }
        }
      } else {
        // `quoteCharacter` is explicitly set
        const preferredQuote = options.quoteCharacter === '\'' ? '\'' : '"';
        // Safety check: If the preferred quote conflicts with value content, switch to the opposite quote
        if ((preferredQuote === '"' && hasDoubleQuote && !hasSingleQuote) || (preferredQuote === "'" && hasSingleQuote && !hasDoubleQuote)) {
          attrQuote = preferredQuote === '"' ? "'" : '"';
        } else if ((preferredQuote === '"' && hasDoubleQuote && hasSingleQuote) || (preferredQuote === "'" && hasSingleQuote && hasDoubleQuote)) {
          // Both quote types present: Fall back to escaping despite `preventAttributesEscaping`
          attrQuote = preferredQuote;
          if (attrQuote === '"') {
            attrValue = attrValue.replace(/"/g, '&#34;');
          } else {
            attrValue = attrValue.replace(/'/g, '&#39;');
          }
        } else {
          attrQuote = preferredQuote;
        }
      }
    }
    emittedAttrValue = attrQuote + attrValue + attrQuote;
    if (!isLast && !options.removeTagWhitespace) {
      emittedAttrValue += ' ';
    }
  } else if (isLast && !hasUnarySlash) {
    // Last attribute in a non-self-closing tag:
    // No space needed
    emittedAttrValue = attrValue;
  } else {
    // Not last attribute, or is a self-closing tag:
    // Unquoted values must have space after them to delimit from next attribute
    emittedAttrValue = attrValue + ' ';
  }

  if (typeof attrValue === 'undefined' || (options.collapseBooleanAttributes &&
      isBooleanAttribute(attrName.toLowerCase(), (attrValue || '').toLowerCase()))) {
    attrFragment = attrName;
    if (!isLast) {
      attrFragment += ' ';
    }
  } else {
    attrFragment = attrName + attr.customAssign + emittedAttrValue;
  }

  return attr.customOpen + attrFragment + attr.customClose;
}

// Imports


// Tag omission rules

function canRemoveParentTag(optionalStartTag, tag) {
  switch (optionalStartTag) {
    case 'html':
    case 'head':
      return true;
    case 'body':
      return !headerElements.has(tag);
    case 'colgroup':
      return tag === 'col';
    case 'tbody':
      return tag === 'tr';
  }
  return false;
}

function isStartTagMandatory(optionalEndTag, tag) {
  switch (tag) {
    case 'colgroup':
      return optionalEndTag === 'colgroup';
    case 'tbody':
      return tableSectionElements.has(optionalEndTag);
  }
  return false;
}

function canRemovePrecedingTag(optionalEndTag, tag) {
  switch (optionalEndTag) {
    case 'html':
    case 'head':
    case 'body':
    case 'colgroup':
    case 'caption':
      return true;
    case 'li':
    case 'optgroup':
    case 'tr':
      return tag === optionalEndTag;
    case 'dt':
    case 'dd':
      return descriptionElements.has(tag);
    case 'p':
      return pBlockElements.has(tag);
    case 'rb':
    case 'rt':
    case 'rp':
      return rubyEndTagOmission.has(tag);
    case 'rtc':
      return rubyRtcEndTagOmission.has(tag);
    case 'option':
      return optionElements.has(tag);
    case 'thead':
    case 'tbody':
      return tableContentElements.has(tag);
    case 'tfoot':
      return tag === 'tbody';
    case 'td':
    case 'th':
      return cellElements.has(tag);
  }
  return false;
}

// Element removal logic

function canRemoveElement(tag, attrs) {
  switch (tag) {
    case 'textarea':
      return false;
    case 'audio':
    case 'script':
    case 'video':
      if (hasAttrName('src', attrs)) {
        return false;
      }
      break;
    case 'iframe':
      if (hasAttrName('src', attrs) || hasAttrName('srcdoc', attrs)) {
        return false;
      }
      break;
    case 'object':
      if (hasAttrName('data', attrs)) {
        return false;
      }
      break;
    case 'applet':
      if (hasAttrName('code', attrs)) {
        return false;
      }
      break;
  }
  return true;
}

/**
 * @param {string} str - Tag name or HTML-like element spec (e.g., “td” or “<span aria-hidden='true'>”)
 * @param {MinifierOptions} options - Options object for name normalization
 * @returns {{tag: string, attrs: Object.<string, string|undefined>|null}|null} Parsed spec or null if invalid
 */
function parseElementSpec(str, options) {
  if (typeof str !== 'string') {
    return null;
  }

  const trimmed = str.trim();
  if (!trimmed) {
    return null;
  }

  // Simple tag name: `td`
  if (!/[<>]/.test(trimmed)) {
    return { tag: options.name(trimmed), attrs: null };
  }

  // HTML-like markup: `<span aria-hidden='true'>` or `<td></td>`
  // Extract opening tag using regex
  const match = trimmed.match(/^<([a-zA-Z][\w:-]*)((?:\s+[^>]*)?)>/);
  if (!match) {
    return null;
  }

  const tag = options.name(match[1]);
  const attrString = match[2];

  if (!attrString.trim()) {
    return { tag, attrs: null };
  }

  // Parse attributes from string
  const attrs = {};
  const attrRegex = /([a-zA-Z][\w:-]*)(?:\s*=\s*(?:"([^"]*)"|'([^']*)'|([^\s>/]+)))?/g;
  let attrMatch;

  while ((attrMatch = attrRegex.exec(attrString))) {
    const attrName = options.name(attrMatch[1]);
    const attrValue = attrMatch[2] ?? attrMatch[3] ?? attrMatch[4];
    // Boolean attributes have no value (undefined)
    attrs[attrName] = attrValue;
  }

  return {
    tag,
    attrs: Object.keys(attrs).length > 0 ? attrs : null
  };
}

/**
 * @param {string[]} input - Array of element specifications from `removeEmptyElementsExcept` option
 * @param {MinifierOptions} options - Options object for parsing
 * @returns {Array<{tag: string, attrs: Object.<string, string|undefined>|null}>} Array of parsed element specs
 */
function parseRemoveEmptyElementsExcept(input, options) {
  if (!Array.isArray(input)) {
    return [];
  }

  return input.map(item => {
    if (typeof item === 'string') {
      const spec = parseElementSpec(item, options);
      if (!spec && options.log) {
        options.log('Warning: Unable to parse “removeEmptyElementsExcept” specification: “' + item + '”');
      }
      return spec;
    }
    if (options.log) {
      options.log('Warning: “removeEmptyElementsExcept” specification must be a string, received: ' + typeof item);
    }
    return null;
  }).filter(Boolean);
}

/**
 * @param {string} tag - Element tag name
 * @param {HTMLAttribute[]} attrs - Array of element attributes
 * @param {Array<{tag: string, attrs: Object.<string, string|undefined>|null}>} preserveList - Parsed preserve specs
 * @returns {boolean} True if the empty element should be preserved
 */
function shouldPreserveEmptyElement(tag, attrs, preserveList) {
  for (const spec of preserveList) {
    // Tag name must match
    if (spec.tag !== tag) {
      continue;
    }

    // If no attributes specified in spec, tag match is enough
    if (!spec.attrs) {
      return true;
    }

    // Check if all specified attributes match
    const allAttrsMatch = Object.entries(spec.attrs).every(([name, value]) => {
      const attr = attrs.find(a => a.name === name);
      if (!attr) {
        return false; // Attribute not present
      }
      // Boolean attribute in spec (undefined value) matches if attribute is present
      if (value === undefined) {
        return true;
      }
      // Valued attribute must match exactly
      return attr.value === value;
    });

    if (allAttrsMatch) {
      return true;
    }
  }

  return false;
}

// Imports


// Lazy-load heavy dependencies only when needed

let lightningCSSPromise;
async function getLightningCSS() {
  if (!lightningCSSPromise) {
    lightningCSSPromise = import('lightningcss').then(m => m.transform);
  }
  return lightningCSSPromise;
}

let terserPromise;
async function getTerser() {
  if (!terserPromise) {
    terserPromise = import('terser').then(m => m.minify);
  }
  return terserPromise;
}

let swcPromise;
async function getSwc() {
  if (!swcPromise) {
    swcPromise = import('@swc/core')
      .then(m => m.default || m)
      .catch(() => {
        throw new Error(
          'The swc minifier requires @swc/core to be installed.\n' +
          'Install it with: npm install @swc/core'
        );
      });
  }
  return swcPromise;
}

// Minification caches (initialized on first use with configurable sizes)
let cssMinifyCache = null;
let jsMinifyCache = null;

// Pre-compiled patterns for script merging (avoid repeated allocation in hot path)
const RE_SCRIPT_ATTRS = /([^\s=]+)(?:=(?:"([^"]*)"|'([^']*)'|([^\s>]+)))?/g;
const SCRIPT_BOOL_ATTRS = new Set(['async', 'defer', 'nomodule']);
const DEFAULT_JS_TYPES = new Set(['', 'text/javascript', 'application/javascript']);

// Pre-compiled patterns for buffer scanning
const RE_START_TAG = /^<[^/!]/;
const RE_END_TAG = /^<\//;

// Script merging

/**
 * Merge consecutive inline script tags into one (`mergeConsecutiveScripts`).
 * Only merges scripts that are compatible:
 * - Both inline (no `src` attribute)
 * - Same `type` (or both default JavaScript)
 * - No conflicting attributes (`async`, `defer`, `nomodule`, different `nonce`)
 *
 * Limitation: This function uses regex-based matching (`pattern` variable below),
 * which can produce incorrect results if a script’s content contains a literal
 * `</script>` string (e.g., `document.write('<script>…</script>')`). In valid
 * HTML, such strings should be escaped as `<\/script>` or split like
 * `'</scr' + 'ipt>'`, so this limitation rarely affects real-world code. The
 * earlier `minifyJS` step (if enabled) typically handles this escaping already.
 *
 * @param {string} html - The HTML string to process
 * @returns {string} HTML with consecutive scripts merged
 */
function mergeConsecutiveScripts(html) {
  // `pattern`: Regex to match consecutive `</script>` followed by `<script…>`.
  // See function JSDoc above for known limitations with literal `</script>` in content.
  // Captures:
  // 1. first script attrs
  // 2. first script content
  // 3. whitespace between
  // 4. second script attrs
  // 5. second script content
  const pattern = /<script([^>]*)>([\s\S]*?)<\/script>([\s]*)<script([^>]*)>([\s\S]*?)<\/script>/gi;

  let result = html;
  let changed = true;

  // Keep merging until no more changes (handles chains of 3+ scripts)
  while (changed) {
    changed = false;
    result = result.replace(pattern, (match, attrs1, content1, whitespace, attrs2, content2) => {
      // Parse attributes from both script tags (uses pre-compiled RE_SCRIPT_ATTRS)
      const parseAttrs = (attrStr) => {
        const attrs = {};
        RE_SCRIPT_ATTRS.lastIndex = 0; // Reset for reuse
        let m;
        while ((m = RE_SCRIPT_ATTRS.exec(attrStr)) !== null) {
          const name = m[1].toLowerCase();
          const value = m[2] ?? m[3] ?? m[4] ?? '';
          attrs[name] = value;
        }
        return attrs;
      };

      const a1 = parseAttrs(attrs1);
      const a2 = parseAttrs(attrs2);

      // Check for `src`—cannot merge external scripts
      if ('src' in a1 || 'src' in a2) {
        return match;
      }

      // Check `type` compatibility (both must be same, or both default JS)
      const type1 = a1.type || '';
      const type2 = a2.type || '';

      if (DEFAULT_JS_TYPES.has(type1) && DEFAULT_JS_TYPES.has(type2)) ; else if (type1 === type2) ; else {
        // Incompatible types
        return match;
      }

      // Check for conflicting boolean attributes (uses pre-compiled SCRIPT_BOOL_ATTRS)
      for (const attr of SCRIPT_BOOL_ATTRS) {
        const has1 = attr in a1;
        const has2 = attr in a2;
        if (has1 !== has2) {
          // One has it, one doesn't - incompatible
          return match;
        }
      }

      // Check `nonce`—must be same or both absent
      if (a1.nonce !== a2.nonce) {
        return match;
      }

      // Scripts are compatible—merge them
      changed = true;

      // Combine content—use semicolon normally, newline only for trailing `//` comments
      const c1 = content1.trim();
      const c2 = content2.trim();
      let mergedContent;
      if (c1 && c2) {
        // Check if last line of c1 contains `//` (single-line comment)
        // If so, use newline to terminate it; otherwise use semicolon (if not already present)
        const lastLine = c1.slice(c1.lastIndexOf('\n') + 1);
        const separator = lastLine.includes('//') ? '\n' : (c1.endsWith(';') ? '' : ';');
        mergedContent = c1 + separator + c2;
      } else {
        mergedContent = c1 || c2;
      }

      // Use first script’s attributes (they should be compatible)
      return `<script${attrs1}>${mergedContent}</script>`;
    });
  }

  return result;
}

// Type definitions

/**
 * @typedef {Object} HTMLAttribute
 *  Representation of an attribute from the HTML parser.
 *
 * @prop {string} name
 * @prop {string} [value]
 * @prop {string} [quote]
 * @prop {string} [customAssign]
 * @prop {string} [customOpen]
 * @prop {string} [customClose]
 */

/**
 * @typedef {Object} MinifierOptions
 *  Options that control how HTML is minified. All of these are optional
 *  and usually default to a disabled/safe value unless noted.
 *
 * @prop {(tag: string, attrs: HTMLAttribute[], canCollapseWhitespace: (tag: string) => boolean) => boolean} [canCollapseWhitespace]
 *  Predicate that determines whether whitespace inside a given element
 *  can be collapsed.
 *
 *  Default: Built-in `canCollapseWhitespace` function
 *
 * @prop {(tag: string | null, attrs: HTMLAttribute[] | undefined, canTrimWhitespace: (tag: string) => boolean) => boolean} [canTrimWhitespace]
 *  Predicate that determines whether leading/trailing whitespace around
 *  the element may be trimmed.
 *
 *  Default: Built-in `canTrimWhitespace` function
 *
 * @prop {number} [cacheCSS]
 *  The maximum number of entries for the CSS minification cache. Higher values
 *  improve performance for inputs with repeated CSS (e.g., batch processing).
 *  - Cache is created on first `minify()` call and persists for the process lifetime
 *  - Cache size is locked after first call—subsequent calls reuse the same cache
 *  - Explicit `0` values are coerced to `1` (minimum functional cache size)
 *
 *  Default: `500`
 *
 * @prop {number} [cacheJS]
 *  The maximum number of entries for the JavaScript minification cache. Higher
 *  values improve performance for inputs with repeated JavaScript.
 *  - Cache is created on first `minify()` call and persists for the process lifetime
 *  - Cache size is locked after first call—subsequent calls reuse the same cache
 *  - Explicit `0` values are coerced to `1` (minimum functional cache size)
 *
 *  Default: `500`
 *
 * @prop {boolean} [caseSensitive]
 *  When true, tag and attribute names are treated as case-sensitive.
 *  Useful for custom HTML tags.
 *  If false (default) names are lower-cased via the `name` function.
 *
 *  Default: `false`
 *
 *  @prop {boolean} [collapseAttributeWhitespace]
 *  Collapse multiple whitespace characters within attribute values into a
 *  single space. Also trims leading and trailing whitespace from attribute
 *  values. Applied as an early normalization step before special attribute
 *  handlers (CSS minification, class sorting, etc.) run.
 *
 *  Default: `false`
 *
 * @prop {boolean} [collapseBooleanAttributes]
 *  Collapse boolean attributes to their name only (for example
 *  `disabled="disabled"` → `disabled`).
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#collapse_boolean_attributes
 *
 *  Default: `false`
 *
 * @prop {boolean} [collapseInlineTagWhitespace]
 *  When false (default) whitespace around `inline` tags is preserved in
 *  more cases. When true, whitespace around inline tags may be collapsed.
 *  Must also enable `collapseWhitespace` to have effect.
 *
 *  Default: `false`
 *
 * @prop {boolean} [collapseWhitespace]
 *  Collapse multiple whitespace characters into one where allowed. Also
 *  controls trimming behaviour in several code paths.
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#collapse_whitespace
 *
 *  Default: `false`
 *
 * @prop {boolean} [conservativeCollapse]
 *  If true, be conservative when collapsing whitespace (preserve more
 *  whitespace in edge cases). Affects collapse algorithms.
 *  Must also enable `collapseWhitespace` to have effect.
 *
 *  Default: `false`
 *
 * @prop {boolean} [continueOnMinifyError]
 *  When set to `false`, minification errors may throw.
 *  By default, the minifier will attempt to recover from minification
 *  errors, or ignore them and preserve the original content.
 *
 *  Default: `true`
 *
 * @prop {boolean} [continueOnParseError]
 *  When true, the parser will attempt to continue on recoverable parse
 *  errors. Otherwise, parsing errors may throw.
 *
 *  Default: `false`
 *
 * @prop {RegExp[]} [customAttrAssign]
 *  Array of regexes used to recognise custom attribute assignment
 *  operators (e.g. `'<div flex?="{{mode != cover}}"></div>'`).
 *  These are concatenated with the built-in assignment patterns.
 *
 *  Default: `[]`
 *
 * @prop {RegExp} [customAttrCollapse]
 *  Regex matching attribute names whose values should be collapsed.
 *  Basically used to remove newlines and excess spaces inside attribute values,
 *  e.g. `/ng-class/`.
 *
 * @prop {[RegExp, RegExp][]} [customAttrSurround]
 *  Array of `[openRegExp, closeRegExp]` pairs used by the parser to
 *  detect custom attribute surround patterns (for non-standard syntaxes,
 *  e.g. `<input {{#if value}}checked="checked"{{/if}}>`).
 *
 * @prop {RegExp[]} [customEventAttributes]
 *  Array of regexes used to detect event handler attributes for `minifyJS`
 *  (e.g. `ng-click`). The default matches standard `on…` event attributes.
 *
 *  Default: `[/^on[a-z]{3,}$/]`
 *
 * @prop {number} [customFragmentQuantifierLimit]
 *  Limits the quantifier used when building a safe regex for custom
 *  fragments to avoid ReDoS. See source use for details.
 *
 *  Default: `200`
 *
 * @prop {boolean} [decodeEntities]
 *  When true, decodes HTML entities in text and attributes before
 *  processing, and re-encodes ambiguous ampersands when outputting.
 *
 *  Default: `false`
 *
 * @prop {boolean} [html5]
 *  Parse and emit using HTML5 rules. Set to `false` to use non-HTML5
 *  parsing behavior.
 *
 *  Default: `true`
 *
 * @prop {RegExp[]} [ignoreCustomComments]
 *  Comments matching any pattern in this array of regexes will be
 *  preserved when `removeComments` is enabled. The default preserves
 *  “bang” comments and comments starting with `#`.
 *
 *  Default: `[/^!/, /^\s*#/]`
 *
 * @prop {RegExp[]} [ignoreCustomFragments]
 *  Array of regexes used to identify fragments that should be
 *  preserved (for example server templates). These fragments are temporarily
 *  replaced during minification to avoid corrupting template code.
 *  The default preserves ASP/PHP-style tags.
 *
 *  Default: `[/<%[\s\S]*?%>/, /<\?[\s\S]*?\?>/]`
 *
 * @prop {boolean} [includeAutoGeneratedTags]
 *  If false, tags marked as auto-generated by the parser will be omitted
 *  from output. Useful to skip injected tags.
 *
 *  Default: `true`
 *
 * @prop {ArrayLike<string>} [inlineCustomElements]
 *  Collection of custom element tag names that should be treated as inline
 *  elements for white-space handling, alongside the built-in inline elements.
 *
 *  Default: `[]`
 *
 * @prop {boolean} [keepClosingSlash]
 *  Preserve the trailing slash in self-closing tags when present.
 *
 *  Default: `false`
 *
 * @prop {(message: unknown) => void} [log]
 *  Logging function used by the minifier for warnings/errors/info.
 *  You can directly provide `console.log`, but `message` may also be an `Error`
 *  object or other non-string value.
 *
 *  Default: `() => {}` (no-op function)
 *
 * @prop {number} [maxInputLength]
 *  The maximum allowed input length. Used as a guard against ReDoS via
 *  pathological inputs. If the input exceeds this length an error is
 *  thrown.
 *
 *  Default: No limit
 *
 * @prop {number} [maxLineLength]
 *  Maximum line length for the output. When set the minifier will wrap
 *  output to the given number of characters where possible.
 *
 *  Default: No limit
 *
 * @prop {boolean} [mergeScripts]
 *  When true, consecutive inline `<script>` elements are merged into one.
 *  Only merges compatible scripts (same `type`, matching `async`/`defer`/
 *  `nomodule`/`nonce` attributes). Does not merge external scripts (with `src`).
 *
 *  Default: `false`
 *
 * @prop {boolean | Partial<import("lightningcss").TransformOptions<import("lightningcss").CustomAtRules>> | ((text: string, type?: string) => Promise<string> | string)} [minifyCSS]
 *  When true, enables CSS minification for inline `<style>` tags or
 *  `style` attributes. If an object is provided, it is passed to
 *  [Lightning CSS](https://www.npmjs.com/package/lightningcss)
 *  as transform options. If a function is provided, it will be used to perform
 *  custom CSS minification. If disabled, CSS is not minified.
 *
 *  Default: `false`
 *
 * @prop {boolean | import("terser").MinifyOptions | {engine?: 'terser' | 'swc', [key: string]: any} | ((text: string, inline?: boolean) => Promise<string> | string)} [minifyJS]
 *  When true, enables JS minification for `<script>` contents and
 *  event handler attributes. If an object is provided, it can include:
 *  - `engine`: The minifier to use (`terser` or `swc`). Default: `terser`.
 *    Note: Inline event handlers (e.g., `onclick="…"`) always use Terser
 *    regardless of engine setting, as swc doesn’t support bare return statements.
 *  - Engine-specific options (e.g., Terser options if `engine: 'terser'`,
 *    SWC options if `engine: 'swc'`).
 *  If a function is provided, it will be used to perform
 *  custom JS minification. If disabled, JS is not minified.
 *
 *  Default: `false`
 *
 * @prop {boolean | string | import("relateurl").Options | ((text: string) => Promise<string> | string)} [minifyURLs]
 *  When true, enables URL rewriting/minification. If an object is provided,
 *  it is passed to [relateurl](https://www.npmjs.com/package/relateurl)
 *  as options. If a string is provided, it is treated as an `{ site: string }`
 *  options object. If a function is provided, it will be used to perform
 *  custom URL minification. If disabled, URLs are not minified.
 *
 *  Default: `false`
 *
 * @prop {boolean | {precision?: number, removeDefaults?: boolean, minifyColors?: boolean}} [minifySVG]
 *  When true, enables SVG-specific optimizations for SVG elements and attributes.
 *  If an object is provided, it can include:
 *  - `precision`: Number of decimal places for numeric values (coordinates, path data, etc.). Default: `3`
 *  - `removeDefaults`: Remove attributes with default values (e.g., `fill="black"`). Default: `true`
 *  - `minifyColors`: Minify color values (hex shortening, rgb to hex conversion). Default: `true`
 *  If disabled, SVG content is minified using standard HTML rules only.
 *
 *  Default: `false`
 *
 * @prop {(name: string) => string} [name]
 *  Function used to normalise tag/attribute names. By default, this lowercases
 *  names, unless `caseSensitive` is enabled.
 *
 *  Default: `(name) => name.toLowerCase()`,
 *  or `(name) => name` (no-op function) if `caseSensitive` is enabled.
 *
 * @prop {boolean} [noNewlinesBeforeTagClose]
 *  When wrapping lines, prevent inserting a newline directly before a
 *  closing tag (useful to keep tags like `</a>` on the same line).
 *
 *  Default: `false`
 *
 * @prop {boolean} [partialMarkup]
 *  When true, treat input as a partial HTML fragment rather than a complete
 *  document. This preserves stray end tags (closing tags without corresponding
 *  opening tags) and prevents auto-closing of unclosed tags at the end of input.
 *  Useful for minifying template fragments, SSI includes, or other partial HTML
 *  that will be combined with other fragments.
 *
 *  Default: `false`
 *
 * @prop {boolean} [preserveLineBreaks]
 *  Preserve a single line break at the start/end of text nodes when
 *  collapsing/trimming whitespace.
 *  Must also enable `collapseWhitespace` to have effect.
 *
 *  Default: `false`
 *
 * @prop {boolean} [preventAttributesEscaping]
 *  When true, attribute values will not be HTML-escaped (dangerous for
 *  untrusted input). By default, attributes are escaped.
 *
 *  Default: `false`
 *
 * @prop {boolean} [processConditionalComments]
 *  When true, conditional comments (for example `<!--[if IE]> … <![endif]-->`)
 *  will have their inner content processed by the minifier.
 *  Useful to minify HTML that appears inside conditional comments.
 *
 *  Default: `false`
 *
 * @prop {string[]} [processScripts]
 *  Array of `type` attribute values for `<script>` elements whose contents
 *  should be processed as HTML
 *  (e.g. `text/ng-template`, `text/x-handlebars-template`, etc.).
 *  When present, the contents of matching script tags are recursively minified,
 *  like normal HTML content.
 *
 *  Default: `[]`
 *
 * @prop {"\"" | "'"} [quoteCharacter]
 *  Preferred quote character for attribute values. If unspecified the
 *  minifier picks the safest quote based on the attribute value.
 *
 *  Default: Auto-detected
 *
 * @prop {boolean} [removeAttributeQuotes]
 *  Remove quotes around attribute values where it is safe to do so.
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#remove_attribute_quotes
 *
 *  Default: `false`
 *
 * @prop {boolean} [removeComments]
 *  Remove HTML comments. Comments that match `ignoreCustomComments` will
 *  still be preserved.
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#remove_comments
 *
 *  Default: `false`
 *
 * @prop {boolean | ((attrName: string, tag: string) => boolean)} [removeEmptyAttributes]
 *  If true, removes attributes whose values are empty (some attributes
 *  are excluded by name). Can also be a function to customise which empty
 *  attributes are removed.
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#remove_empty_or_blank_attributes
 *
 *  Default: `false`
 *
 * @prop {boolean} [removeEmptyElements]
 *  Remove elements that are empty and safe to remove (for example
 *  `<script />` without `src`).
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#remove_empty_elements
 *
 *  Default: `false`
 *
 * @prop {string[]} [removeEmptyElementsExcept]
 *  Specifies empty elements to preserve when `removeEmptyElements` is enabled.
 *  Has no effect unless `removeEmptyElements: true`.
 *
 *  Accepts tag names or HTML-like element specifications:
 *
 *  * Tag name only: `["td", "span"]`—preserves all empty elements of these types
 *  * With valued attributes: `["<span aria-hidden='true'>"]`—preserves only when attribute values match
 *  * With boolean attributes: `["<input disabled>"]`—preserves only when boolean attribute is present
 *  * Mixed: `["<button type='button' disabled>"]`—all specified attributes must match
 *
 *  Attribute matching:
 *
 *  * All specified attributes must be present and match (valued attributes must have exact values)
 *  * Additional attributes on the element are allowed
 *  * Attribute name matching respects the `caseSensitive` option
 *  * Supports double quotes, single quotes, and unquoted attribute values in specifications
 *
 *  Limitations:
 *
 *  * Self-closing syntax (e.g., `["<span/>"]`) is not supported; use `["span"]` instead
 *  * Definitions containing `>` within quoted attribute values (e.g., `["<span title='a>b'>"]`) are not supported
 *
 *  Default: `[]`
 *
 * @prop {boolean} [removeOptionalTags]
 *  Drop optional start/end tags where the HTML specification permits it
 *  (for example `</li>`, optional `<html>` etc.).
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#remove_optional_tags
 *
 *  Default: `false`
 *
 * @prop {boolean} [removeRedundantAttributes]
 *  Remove attributes that are redundant because they match the element’s
 *  default values (for example `<button type="submit">`).
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#remove_redundant_attributes
 *
 *  Default: `false`
 *
 * @prop {boolean} [removeScriptTypeAttributes]
 *  Remove `type` attributes from `<script>` when they are unnecessary
 *  (e.g. `type="text/javascript"`).
 *
 *  Default: `false`
 *
 * @prop {boolean} [removeStyleLinkTypeAttributes]
 *  Remove `type` attributes from `<style>` and `<link>` elements when
 *  they are unnecessary (e.g. `type="text/css"`).
 *
 *  Default: `false`
 *
 * @prop {boolean} [removeTagWhitespace]
 *  **Note that this will result in invalid HTML!**
 *
 *  When true, extra whitespace between tag name and attributes (or before
 *  the closing bracket) will be removed where possible. Affects output spacing
 *  such as the space used in the short doctype representation.
 *
 *  Default: `false`
 *
 * @prop {boolean | ((tag: string, attrs: HTMLAttribute[]) => void)} [sortAttributes]
 *  When true, enables sorting of attributes. If a function is provided it
 *  will be used as a custom attribute sorter, which should mutate `attrs`
 *  in-place to the desired order. If disabled, the minifier will attempt to
 *  preserve the order from the input.
 *
 *  Default: `false`
 *
 * @prop {boolean | ((value: string) => string)} [sortClassName]
 *  When true, enables sorting of class names inside `class` attributes.
 *  If a function is provided it will be used to transform/sort the class
 *  name string. If disabled, the minifier will attempt to preserve the
 *  class-name order from the input.
 *
 *  Default: `false`
 *
 * @prop {boolean} [trimCustomFragments]
 *  When true, whitespace around ignored custom fragments may be trimmed
 *  more aggressively. This affects how preserved fragments interact with
 *  surrounding whitespace collapse.
 *
 *  Default: `false`
 *
 * @prop {boolean} [useShortDoctype]
 *  Replace the HTML doctype with the short `<!doctype html>` form.
 *  See also: https://perfectionkills.com/experimenting-with-html-minifier/#use_short_doctype
 *
 *  Default: `false`
 */

async function createSortFns(value, options, uidIgnore, uidAttr, ignoredMarkupChunks) {
  const attrChains = options.sortAttributes && Object.create(null);
  const classChain = options.sortClassName && new TokenChain();

  function attrNames(attrs) {
    return attrs.map(function (attr) {
      return options.name(attr.name);
    });
  }

  function shouldSkipUID(token, uid) {
    return !uid || token.indexOf(uid) === -1;
  }

  function shouldKeepToken(token) {
    // Filter out any HTML comment tokens (UID placeholders)
    // These are temporary markers created by `htmlmin:ignore` and `ignoreCustomFragments`
    if (token.startsWith('<!--') && token.endsWith('-->')) {
      return false;
    }
    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);
  }

  // Pre-compile regex patterns for reuse (performance optimization)
  // These must be declared before `scan()` since scan uses them
  const whitespaceSplitPatternScan = /[ \t\n\f\r]+/;
  const whitespaceSplitPatternSort = /[ \n\f\r]+/;

  async function scan(input) {
    let currentTag, currentType;
    const parser = new HTMLParser(input, {
      start: function (tag, attrs) {
        if (attrChains) {
          if (!attrChains[tag]) {
            attrChains[tag] = new TokenChain();
          }
          const attrNamesList = attrNames(attrs).filter(shouldKeepToken);
          attrChains[tag].add(attrNamesList);
        }
        for (let i = 0, len = attrs.length; i < len; i++) {
          const attr = attrs[i];
          if (classChain && attr.value && options.name(attr.name) === 'class') {
            const classes = trimWhitespace(attr.value).split(whitespaceSplitPatternScan).filter(shouldKeepToken);
            classChain.add(classes);
          } else if (options.processScripts && attr.name.toLowerCase() === 'type') {
            currentTag = tag;
            currentType = attr.value;
          }
        }
      },
      end: function () {
        currentTag = '';
      },
      chars: async function (text) {
        // Only recursively scan HTML content, not JSON-LD or other non-HTML script types
        // `scan()` is for analyzing HTML attribute order, not for parsing JSON
        if (options.processScripts && specialContentElements.has(currentTag) &&
            options.processScripts.indexOf(currentType) > -1 &&
            currentType === 'text/html') {
          await scan(text);
        }
      },
      // We never need `nextTag` information in this scan
      wantsNextTag: false,
      // Continue on parse errors during analysis pass
      continueOnParseError: options.continueOnParseError
    });

    try {
      await parser.parse();
    } catch (err) {
      // If parsing fails during analysis pass, just skip it—we’ll still have partial frequency data from what we could parse
      if (!options.continueOnParseError) {
        throw err;
      }
    }
  }

  // For the first pass, create a copy of options and disable aggressive minification.
  // Keep attribute transformations (like `removeStyleLinkTypeAttributes`) for accurate analysis.
  // This is safe because `createSortFns` is called before custom fragment UID markers (`uidAttr`) are added.
  // Note: `htmlmin:ignore` UID markers (`uidIgnore`) already exist and are expanded for analysis.
  const firstPassOptions = Object.assign({}, options, {
    // Disable sorting for the analysis pass
    sortAttributes: false,
    sortClassName: false,
    // Disable aggressive minification that doesn’t affect attribute analysis
    collapseWhitespace: false,
    removeAttributeQuotes: false,
    removeTagWhitespace: false,
    decodeEntities: false,
    processScripts: false,
    // Keep `ignoreCustomFragments` to handle template syntax correctly
    // This is safe because `createSortFns` is now called before UID markers are added
    // Continue on parse errors during analysis (e.g., template syntax)
    continueOnParseError: true,
    log: identity
  });

  // Temporarily enable `continueOnParseError` for the `scan()` function call below.
  // Note: `firstPassOptions` already has `continueOnParseError: true` for the `minifyHTML` call.
  const originalContinueOnParseError = options.continueOnParseError;
  options.continueOnParseError = true;

  // Pre-compile regex patterns for UID replacement and custom fragments
  const uidReplacePattern = uidIgnore && ignoredMarkupChunks
    ? new RegExp('<!--' + uidIgnore + '(\\d+)-->', 'g')
    : null;
  const customFragmentPattern = options.ignoreCustomFragments && options.ignoreCustomFragments.length > 0
    ? new RegExp('(' + options.ignoreCustomFragments.map(re => re.source).join('|') + ')', 'g')
    : null;

  try {
    // Expand UID tokens back to the original content for frequency analysis
    let expandedValue = value;
    if (uidReplacePattern) {
      expandedValue = value.replace(uidReplacePattern, function (match, index) {
        return ignoredMarkupChunks[+index] || '';
      });
      // Reset `lastIndex` for pattern reuse
      uidReplacePattern.lastIndex = 0;
    }

    // First pass minification applies attribute transformations like `removeStyleLinkTypeAttributes` for accurate frequency analysis
    const firstPassOutput = await minifyHTML(expandedValue, firstPassOptions);

    // For frequency analysis, we need to remove custom fragments temporarily
    // because HTML comments in opening tags prevent proper attribute parsing.
    // We remove them with a space to preserve attribute boundaries.
    let scanValue = firstPassOutput;
    if (customFragmentPattern) {
      scanValue = firstPassOutput.replace(customFragmentPattern, ' ');
    }

    await scan(scanValue);
  } finally {
    // Restore original option
    options.continueOnParseError = originalContinueOnParseError;
  }
  if (attrChains) {
    const attrSorters = Object.create(null);
    for (const tag in attrChains) {
      attrSorters[tag] = attrChains[tag].createSorter();
    }
    // Memoize sorted attribute orders—attribute sets often repeat in templates
    const attrOrderCache = new LRU(500);

    options.sortAttributes = function (tag, attrs) {
      const sorter = attrSorters[tag];
      if (sorter) {
        const names = attrNames(attrs);

        // Create order-independent cache key from tag and sorted attribute names
        const cacheKey = tag + ':' + names.slice().sort().join(',');
        let sortedNames = attrOrderCache.get(cacheKey);

        if (sortedNames === undefined) {
          // Only sort if not in cache—need to clone names since sort mutates in place
          sortedNames = sorter.sort(names.slice());
          attrOrderCache.set(cacheKey, sortedNames);
        }

        // Apply the sorted order to `attrs`
        const attrMap = Object.create(null);
        names.forEach(function (name, index) {
          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);
        });
        sortedNames.forEach(function (name, index) {
          attrs[index] = attrMap[name].shift();
        });
      }
    };
  }
  if (classChain) {
    const sorter = classChain.createSorter();
    // Memoize `sortClassName` results—class lists often repeat in templates
    const classNameCache = new LRU(500);

    options.sortClassName = function (value) {
      // Fast path: Single class (no spaces) needs no sorting
      if (value.indexOf(' ') === -1) {
        return value;
      }

      // Check cache first
      const cached = classNameCache.get(value);
      if (cached !== undefined) {
        return cached;
      }

      // Expand UID tokens back to original content before sorting
      // Fast path: Skip if no HTML comments (UID markers) present
      let expandedValue = value;
      if (uidReplacePattern && value.indexOf('<!--') !== -1) {
        expandedValue = value.replace(uidReplacePattern, function (match, index) {
          return ignoredMarkupChunks[+index] || '';
        });
        // Reset `lastIndex` for pattern reuse
        uidReplacePattern.lastIndex = 0;
      }
      const classes = expandedValue.split(whitespaceSplitPatternSort).filter(function(cls) {
        return cls !== '';
      });
      const sorted = sorter.sort(classes);
      const result = sorted.join(' ');

      // Cache the result
      classNameCache.set(value, result);
      return result;
    };
  }
}

/**
 * @param {string} value - HTML content to minify
 * @param {MinifierOptions} options - Normalized minification options
 * @param {boolean} [partialMarkup] - Whether treating input as partial markup
 * @returns {Promise<string>} Minified HTML
 */
async function minifyHTML(value, options, partialMarkup) {
  // Check input length limitation to prevent ReDoS attacks
  if (options.maxInputLength && value.length > options.maxInputLength) {
    throw new Error(`Input length (${value.length}) exceeds maximum allowed length (${options.maxInputLength})`);
  }

  if (options.collapseWhitespace) {
    value = collapseWhitespace(value, options, true, true);
  }

  const buffer = [];
  let charsPrevTag;
  let currentChars = '';
  let hasChars;
  let currentTag = '';
  let currentAttrs = [];
  const stackNoTrimWhitespace = [];
  const stackNoCollapseWhitespace = [];
  let optionalStartTag = '';
  let optionalEndTag = '';
  const ignoredMarkupChunks = [];
  const ignoredCustomMarkupChunks = [];
  let uidIgnore;
  let uidIgnorePlaceholderPattern;
  let uidAttr;
  let uidPattern;
  // Create inline tags/text sets with custom elements
  const customElementsInput = options.inlineCustomElements ?? [];
  const customElementsArr = Array.isArray(customElementsInput) ? customElementsInput : Array.from(customElementsInput);
  const normalizedCustomElements = customElementsArr.map(name => options.name(name));
  // Fast path: Reuse base sets if no custom elements
  const inlineTextSet = normalizedCustomElements.length
    ? new Set([...inlineElementsToKeepWhitespaceWithin, ...normalizedCustomElements])
    : inlineElementsToKeepWhitespaceWithin;
  const inlineElements = normalizedCustomElements.length
    ? new Set([...inlineElementsToKeepWhitespaceAround, ...normalizedCustomElements])
    : inlineElementsToKeepWhitespaceAround;

  // Parse `removeEmptyElementsExcept` option
  let removeEmptyElementsExcept;
  if (options.removeEmptyElementsExcept && !Array.isArray(options.removeEmptyElementsExcept)) {
    if (options.log) {
      options.log('Warning: “removeEmptyElementsExcept” option must be an array, received: ' + typeof options.removeEmptyElementsExcept);
    }
    removeEmptyElementsExcept = [];
  } else {
    removeEmptyElementsExcept = parseRemoveEmptyElementsExcept(options.removeEmptyElementsExcept, options) || [];
  }

  // Temporarily replace ignored chunks with comments, so that we don’t have to worry what’s there.
  // For all we care there might be completely-horribly-broken-alien-non-html-emoji-cthulhu-filled content
  value = value.replace(/<!-- htmlmin:ignore -->([\s\S]*?)<!-- htmlmin:ignore -->/g, function (match, group1) {
    if (!uidIgnore) {
      uidIgnore = uniqueId(value);
      const pattern = new RegExp('^' + uidIgnore + '([0-9]+)$');
      uidIgnorePlaceholderPattern = new RegExp('^<!--' + uidIgnore + '(\\d+)-->$');
      if (options.ignoreCustomComments) {
        options.ignoreCustomComments = options.ignoreCustomComments.slice();
      } else {
        options.ignoreCustomComments = [];
      }
      options.ignoreCustomComments.push(pattern);
    }
    const token = '<!--' + uidIgnore + ignoredMarkupChunks.length + '-->';
    ignoredMarkupChunks.push(group1);
    return token;
  });

  // Create sort functions after `htmlmin:ignore` processing but before custom fragment UID markers
  // This allows proper frequency analysis with access to ignored content via UID tokens
  if ((options.sortAttributes && typeof options.sortAttributes !== 'function') ||
      (options.sortClassName && typeof options.sortClassName !== 'function')) {
    await createSortFns(value, options, uidIgnore, null, ignoredMarkupChunks);
  }

  const customFragments = options.ignoreCustomFragments.map(function (re) {
    return re.source;
  });
  if (customFragments.length) {
    // Warn about potential ReDoS if custom fragments use unlimited quantifiers
    for (let i = 0; i < customFragments.length; i++) {
      if (/[*+]/.test(customFragments[i])) {
        options.log('Warning: Custom fragment contains unlimited quantifiers (“*” or “+”) which may cause ReDoS vulnerability');
        break;
      }
    }

    // Safe approach: Use bounded quantifiers instead of unlimited ones to prevent ReDoS
    const maxQuantifier = options.customFragmentQuantifierLimit || 200;
    const whitespacePattern = `\\s{0,${maxQuantifier}}`;

    // Use bounded quantifiers to prevent ReDoS—this approach prevents exponential backtracking
    const reCustomIgnore = new RegExp(
      whitespacePattern + '(?:' + customFragments.join('|') + '){1,' + maxQuantifier + '}' + whitespacePattern,
      'g'
    );
    // Temporarily replace custom ignored fragments with unique attributes
    value = value.replace(reCustomIgnore, function (match) {
      if (!uidAttr) {
        uidAttr = uniqueId(value);
        uidPattern = new RegExp('(\\s*)' + uidAttr + '([0-9]+)' + uidAttr + '(\\s*)', 'g');

        if (options.minifyCSS) {
          options.minifyCSS = (function (fn) {
            return function (text, type) {
              text = text.replace(uidPattern, function (match, prefix, index) {
                const chunks = ignoredCustomMarkupChunks[+index];
                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
              });

              return fn(text, type);
            };
          })(options.minifyCSS);
        }

        if (options.minifyJS) {
          options.minifyJS = (function (fn) {
            return function (text, type) {
              return fn(text.replace(uidPattern, function (match, prefix, index) {
                const chunks = ignoredCustomMarkupChunks[+index];
                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
              }), type);
            };
          })(options.minifyJS);
        }
      }

      const token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;
      ignoredCustomMarkupChunks.push(/^(\s*)[\s\S]*?(\s*)$/.exec(match));
      return '\t' + token + '\t';
    });
  }

  function canCollapseWhitespace$1(tag, attrs) {
    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);
  }

  function canTrimWhitespace$1(tag, attrs) {
    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);
  }

  function removeStartTag() {
    let index = buffer.length - 1;
    while (index > 0 && !RE_START_TAG.test(buffer[index])) {
      index--;
    }
    buffer.length = Math.max(0, index);
  }

  function removeEndTag() {
    let index = buffer.length - 1;
    while (index > 0 && !RE_END_TAG.test(buffer[index])) {
      index--;
    }
    buffer.length = Math.max(0, index);
  }

  // Look for trailing whitespaces, bypass any inline tags
  function trimTrailingWhitespace(index, nextTag) {
    for (let endTag = null; index >= 0 && canTrimWhitespace$1(endTag); index--) {
      const str = buffer[index];
      const match = str.match(/^<\/([\w:-]+)>$/);
      if (match) {
        endTag = match[1];
      } else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, [], [], options, inlineElements, inlineTextSet))) {
        break;
      }
    }
  }

  // Look for trailing whitespaces from previously processed text
  // which may not be trimmed due to a following comment or an empty
  // element which has now been removed
  function squashTrailingWhitespace(nextTag) {
    let charsIndex = buffer.length - 1;
    if (buffer.length > 1) {
      const item = buffer[buffer.length - 1];
      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {
        charsIndex--;
      }
    }
    trimTrailingWhitespace(charsIndex, nextTag);
  }

  const parser = new HTMLParser(value, {
    partialMarkup: partialMarkup ?? options.partialMarkup,
    continueOnParseError: options.continueOnParseError,
    customAttrAssign: options.customAttrAssign,
    customAttrSurround: options.customAttrSurround,
    html5: options.html5,
    // Compute `nextTag` only when whitespace collapse features require it
    wantsNextTag: !!(options.collapseWhitespace || options.collapseInlineTagWhitespace || options.conservativeCollapse),

    start: async function (tag, attrs, unary, unarySlash, autoGenerated) {
      const lowerTag = tag.toLowerCase();
      if (lowerTag === 'svg' || lowerTag === 'math') {
        options = Object.create(options);
        options.caseSensitive = true;
        options.keepClosingSlash = true;
        options.name = identity;
        options.insideSVG = lowerTag === 'svg';
      }
      tag = options.name(tag);
      currentTag = tag;
      charsPrevTag = tag;
      if (!inlineTextSet.has(tag)) {
        currentChars = '';
      }
      hasChars = false;
      currentAttrs = attrs;

      let optional = options.removeOptionalTags;
      if (optional) {
        const htmlTag = htmlElements.has(tag);
        // `<html>` may be omitted if first thing inside is not a comment
        // `<head>` may be omitted if first thing inside is an element
        // `<body>` may be omitted if first thing inside is not space, comment, `<meta>`, `<link>`, `<script>`, `<style>`, or `<template>`
        // `<colgroup>` may be omitted if first thing inside is `<col>`
        // `<tbody>` may be omitted if first thing inside is `<tr>`
        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {
          removeStartTag();
        }
        optionalStartTag = '';
        // End-tag-followed-by-start-tag omission rules
        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {
          removeEndTag();
          // `<colgroup>` cannot be omitted if preceding `</colgroup>` is omitted
          // `<tbody>` cannot be omitted if preceding `</tbody>`, `</thead>`, or `</tfoot>` is omitted
          optional = !isStartTagMandatory(optionalEndTag, tag);
        }
        optionalEndTag = '';
      }

      // Set whitespace flags for nested tags (e.g., `<code>` within a `<pre>`)
      if (options.collapseWhitespace) {
        if (!stackNoTrimWhitespace.length) {
          squashTrailingWhitespace(tag);
        }
        if (!unary) {
          if (!canTrimWhitespace$1(tag, attrs) || stackNoTrimWhitespace.length) {
            stackNoTrimWhitespace.push(tag);
          }
          if (!canCollapseWhitespace$1(tag, attrs) || stackNoCollapseWhitespace.length) {
            stackNoCollapseWhitespace.push(tag);
          }
        }
      }

      const openTag = '<' + tag;
      const hasUnarySlash = unarySlash && options.keepClosingSlash;

      buffer.push(openTag);

      if (options.sortAttributes) {
        options.sortAttributes(tag, attrs);
      }

      const parts = [];
      for (let i = attrs.length, isLast = true; --i >= 0;) {
        const normalized = await normalizeAttr(attrs[i], attrs, tag, options, minifyHTML);
        if (normalized) {
          parts.push(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));
          isLast = false;
        }
      }
      parts.reverse();
      if (parts.length > 0) {
        buffer.push(' ');
        buffer.push.apply(buffer, parts);
      } else if (optional && optionalStartTags.has(tag)) {
        // Start tag must never be omitted if it has any attributes
        optionalStartTag = tag;
      }

      buffer.push(buffer.pop() + (hasUnarySlash ? '/' : '') + '>');

      if (autoGenerated && !options.includeAutoGeneratedTags) {
        removeStartTag();
        optionalStartTag = '';
      }
    },
    end: function (tag, attrs, autoGenerated) {
      const lowerTag = tag.toLowerCase();
      if (lowerTag === 'svg' || lowerTag === 'math') {
        options = Object.getPrototypeOf(options);
      }
      tag = options.name(tag);

      // Check if current tag is in a whitespace stack
      if (options.collapseWhitespace) {
        if (stackNoTrimWhitespace.length) {
          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {
            stackNoTrimWhitespace.pop();
          }
        } else {
          squashTrailingWhitespace('/' + tag);
        }
        if (stackNoCollapseWhitespace.length &&
            tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {
          stackNoCollapseWhitespace.pop();
        }
      }

      let isElementEmpty = false;
      if (tag === currentTag) {
        currentTag = '';
        isElementEmpty = !hasChars;
      }

      if (options.removeOptionalTags) {
        // `<html>`, `<head>` or `<body>` may be omitted if the element is empty
        if (isElementEmpty && topLevelElements.has(optionalStartTag)) {
          removeStartTag();
        }
        optionalStartTag = '';
        // `</html>` or `</body>` may be omitted if not followed by comment
        // `</head>` may be omitted if not followed by space or comment
        // `</p>` may be omitted if no more content in non-`</a>` parent
        // except for `</dt>` or `</thead>`, end tags may be omitted if no more content in parent element
        if (tag && optionalEndTag && !trailingElements.has(optionalEndTag) && (optionalEndTag !== 'p' || !pInlineElements.has(tag))) {
          removeEndTag();
        }
        optionalEndTag = optionalEndTags.has(tag) ? tag : '';
      }

      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {
        let preserve = false;
        if (removeEmptyElementsExcept.length) {
          // Normalize attribute names for comparison with specs
          const normalizedAttrs = attrs.map(attr => ({ ...attr, name: options.name(attr.name) }));
          preserve = shouldPreserveEmptyElement(tag, normalizedAttrs, removeEmptyElementsExcept);
        }

        if (!preserve) {
          // Remove last element from buffer
          removeStartTag();
          optionalStartTag = '';
          optionalEndTag = '';
        } else {
          // Preserve the element—add closing tag
          if (autoGenerated && !options.includeAutoGeneratedTags) {
            optionalEndTag = '';
          } else {
            buffer.push('</' + tag + '>');
          }
          charsPrevTag = '/' + tag;
          if (!inlineElements.has(tag)) {
            currentChars = '';
          } else if (isElementEmpty) {
            currentChars += '|';
          }
        }
      } else {
        if (autoGenerated && !options.includeAutoGeneratedTags) {
          optionalEndTag = '';
        } else {
          buffer.push('</' + tag + '>');
        }
        charsPrevTag = '/' + tag;
        if (!inlineElements.has(tag)) {
          currentChars = '';
        } else if (isElementEmpty) {
          currentChars += '|';
        }
      }
    },
    chars: async function (text, prevTag, nextTag, prevAttrs, nextAttrs) {
      prevTag = prevTag === '' ? 'comment' : prevTag;
      nextTag = nextTag === '' ? 'comment' : nextTag;
      prevAttrs = prevAttrs || [];
      nextAttrs = nextAttrs || [];
      if (options.decodeEntities && text && !specialContentElements.has(currentTag)) {
        if (text.indexOf('&') !== -1) {
          text = entities.decodeHTML(text);
        }
      }
      // Trim outermost newline-based whitespace inside `pre`/`textarea` elements
      // This removes trailing newlines often added by template engines before closing tags
      // Only trims single trailing newlines (multiple newlines are likely intentional formatting)
      if (options.collapseWhitespace && stackNoTrimWhitespace.length) {
        const topTag = stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1];
        if (stackNoTrimWhitespace.includes('pre') || stackNoTrimWhitespace.includes('textarea')) {
          // Trim trailing whitespace only if it ends with a single newline (not multiple)
          // Multiple newlines are likely intentional formatting, single newline is often a template artifact
          // Treat CRLF (`\r\n`), CR (`\r`), and LF (`\n`) as single line-ending units
          if (nextTag && nextTag === '/' + topTag && /[^\r\n](?:\r\n|\r|\n)[ \t]*$/.test(text)) {
            text = text.replace(/(?:\r\n|\r|\n)[ \t]*$/, '');
          }
        }
      }
      if (options.collapseWhitespace) {
        if (!stackNoTrimWhitespace.length) {
          if (prevTag === 'comment') {
            const prevComment = buffer[buffer.length - 1];
            if (prevComment.indexOf(uidIgnore) === -1) {
              if (!prevComment) {
                prevTag = charsPrevTag;
              }
              if (buffer.length > 1 && (!prevComment || (!options.conservativeCollapse && / $/.test(currentChars)))) {
                const charsIndex = buffer.length - 2;
                buffer[charsIndex] = buffer[charsIndex].replace(/\s+$/, function (trailingSpaces) {
                  text = trailingSpaces + text;
                  return '';
                });
              }
            }
          }
          if (prevTag) {
            if (prevTag === '/nobr' || prevTag === 'wbr') {
              if (/^\s/.test(text)) {
                let tagIndex = buffer.length - 1;
                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf('<' + prevTag) !== 0) {
                  tagIndex--;
                }
                trimTrailingWhitespace(tagIndex - 1, 'br');
              }
            } else if (inlineTextSet.has(prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag)) {
              text = collapseWhitespace(text, options, /(?:^|\s)$/.test(currentChars));
            }
          }
          if (prevTag || nextTag) {
            text = collapseWhitespaceSmart(text, prevTag, nextTag, prevAttrs, nextAttrs, options, inlineElements, inlineTextSet);
          } else {
            text = collapseWhitespace(text, options, true, true);
          }
          if (!text && /\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === '/') {
            trimTrailingWhitespace(buffer.length - 1, nextTag);
          }
        }
        if (!stackNoCollapseWhitespace.length && nextTag !== 'html' && !(prevTag && nextTag)) {
          text = collapseWhitespace(text, options, false, false, true);
        }
      }
      if (specialContentElements.has(currentTag) && (options.processScripts || hasJsonScriptType(currentAttrs))) {
        text = await processScript(text, options, currentAttrs, minifyHTML);
      }
      if (isExecutableScript(currentTag, currentAttrs)) {
        text = await options.minifyJS(text);
      }
      if (isStyleElement(currentTag, currentAttrs)) {
        text = await options.minifyCSS(text);
      }
      if (options.removeOptionalTags && text) {
        // `<html>` may be omitted if first thing inside is not a comment
        // `<body>` may be omitted if first thing inside is not space, comment, `<meta>`, `<link>`, `<script>`, `<style>`, or `<template>`
        if (optionalStartTag === 'html' || (optionalStartTag === 'body' && !/^\s/.test(text))) {
          removeStartTag();
        }
        optionalStartTag = '';
        // `</html>` or `</body>` may be omitted if not followed by comment
        // `</head>`, `</colgroup>`, or `</caption>` may be omitted if not followed by space or comment
        if (compactElements.has(optionalEndTag) || (looseElements.has(optionalEndTag) && !/^\s/.test(text))) {
          removeEndTag();
        }
        // Don’t reset optionalEndTag if text is only whitespace and will be collapsed (not conservatively)
        if (!/^\s+$/.test(text) || !options.collapseWhitespace || options.conservativeCollapse) {
          optionalEndTag = '';
        }
      }
      charsPrevTag = /^\s*$/.test(text) ? prevTag : 'comment';
      if (options.decodeEntities && text && !specialContentElements.has(currentTag)) {
        // Escape any `&` symbols that start either:
        // 1. a legacy-named character reference (i.e., one that doesn’t end with `;`)
        // 2. or any other character reference (i.e., one that does end with `;`)
        // Note that `&` can be escaped as `&amp`, without the semicolon.
        // https://mathiasbynens.be/notes/ambiguous-ampersands
        if (text.indexOf('&') !== -1) {
          text = text.replace(RE_LEGACY_ENTITIES, '&amp$1');
        }
        if (text.indexOf('<') !== -1) {
          text = text.replace(RE_ESCAPE_LT, '&lt;');
        }
      }
      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {
        text = text.replace(uidPattern, function (match, prefix, index) {
          return ignoredCustomMarkupChunks[+index][0];
        });
      }
      currentChars += text;
      if (text) {
        hasChars = true;
      }
      buffer.push(text);
    },
    comment: async function (text, nonStandard) {
      const prefix = nonStandard ? '<!' : '<!--';
      const suffix = nonStandard ? '>' : '-->';
      if (isConditionalComment(text)) {
        text = prefix + await cleanConditionalComment(text, options, minifyHTML) + suffix;
      } else if (options.removeComments) {
        if (isIgnoredComment(text, options)) {
          text = '<!--' + text + '-->';
        } else {
          text = '';
        }
      } else {
        text = prefix + text + suffix;
      }
      if (options.removeOptionalTags && text) {
        // Preceding comments suppress tag omissions
        optionalStartTag = '';
        optionalEndTag = '';
      }

      // Optimize whitespace collapsing between consecutive `htmlmin:ignore` placeholder comments
      if (options.collapseWhitespace && text && uidIgnorePlaceholderPattern) {
        if (uidIgnorePlaceholderPattern.test(text)) {
          // Check if previous buffer items are: [ignore-placeholder, whitespace-only text]
          if (buffer.length >= 2) {
            const prevText = buffer[buffer.length - 1];
            const prevComment = buffer[buffer.length - 2];

            // Check if previous item is whitespace-only and item before that is ignore-placeholder
            if (prevText && /^\s+$/.test(prevText) && prevComment && uidIgnorePlaceholderPattern.test(prevComment)) {
              // Extract the index from both placeholders to check their content
              const currentMatch = text.match(uidIgnorePlaceholderPattern);
              const prevMatch = prevComment.match(uidIgnorePlaceholderPattern);

              if (currentMatch && prevMatch) {
                const currentIndex = +currentMatch[1];
                const prevIndex = +prevMatch[1];

                // Defensive bounds check to ensure indices are valid
                if (currentIndex < ignoredMarkupChunks.length && prevIndex < ignoredMarkupChunks.length) {
                  const currentContent = ignoredMarkupChunks[currentIndex];
                  const prevContent = ignoredMarkupChunks[prevIndex];

                  // Only collapse whitespace if both blocks contain HTML (start with `<`)
                  // Don’t collapse if either contains plain text, as that would change meaning
                  // Note: This check will match HTML comments (`<!-- … -->`), but the tag name
                  // regex below requires starting with a letter, so comments are intentionally
                  // excluded by the `currentTagMatch && prevTagMatch` guard
                  if (currentContent && prevContent && /^\s*</.test(currentContent) && /^\s*</.test(prevContent)) {
                    // Extract tag names from the HTML content (excludes comments, processing instructions, etc.)
                    const currentTagMatch = currentContent.match(/^\s*<([a-zA-Z][\w:-]*)/);
                    const prevTagMatch = prevContent.match(/^\s*<([a-zA-Z][\w:-]*)/);

                    // Only collapse if both matched valid element tags (not comments/text)
                    // and both tags are block-level (inline elements need whitespace preserved)
                    if (currentTagMatch && prevTagMatch) {
                      const currentTag = options.name(currentTagMatch[1]);
                      const prevTag = options.name(prevTagMatch[1]);

                      // Don’t collapse between inline elements
                      if (!inlineElements.has(currentTag) && !inlineElements.has(prevTag)) {
                        // Collapse whitespace respecting context rules
                        let collapsedText = prevText;

                        // Apply `collapseWhitespace` with appropriate context
                        if (!stackNoTrimWhitespace.length && !stackNoCollapseWhitespace.length) {
                          // Not in pre or other no-collapse context
                          if (options.preserveLineBreaks && /[\n\r]/.test(prevText)) {
                            // Preserve line break as single newline
                            collapsedText = '\n';
                          } else if (options.conservativeCollapse) {
                            // Conservative mode: keep single space
                            collapsedText = ' ';
                          } else {
                            // Aggressive mode: remove all whitespace
                            collapsedText = '';
                          }
                        }

                        // Replace the whitespace in buffer
                        buffer[buffer.length - 1] = collapsedText;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      buffer.push(text);
    },
    doctype: function (doctype) {
      buffer.push(options.useShortDoctype
        ? '<!doctype' +
        (options.removeTagWhitespace ? '' : ' ') + 'html>'
        : collapseWhitespaceAll(doctype));
    }
  });

  await parser.parse();

  if (options.removeOptionalTags) {
    // `<html>` may be omitted if first thing inside is not a comment
    // `<head>` or `<body>` may be omitted if empty
    if (topLevelElements.has(optionalStartTag)) {
      removeStartTag();
    }
    // except for `</dt>` or `</thead>`, end tags may be omitted if no more content in parent element
    if (optionalEndTag && !trailingElements.has(optionalEndTag)) {
      removeEndTag();
    }
  }
  if (options.collapseWhitespace) {
    squashTrailingWhitespace('br');
  }

  return joinResultSegments(buffer, options, uidPattern
    ? function (str) {
      return str.replace(uidPattern, function (match, prefix, index, suffix) {
        let chunk = ignoredCustomMarkupChunks[+index][0];
        if (options.collapseWhitespace) {
          if (prefix !== '\t') {
            chunk = prefix + chunk;
          }
          if (suffix !== '\t') {
            chunk += suffix;
          }
          return collapseWhitespace(chunk, {
            preserveLineBreaks: options.preserveLineBreaks,
            conservativeCollapse: !options.trimCustomFragments
          }, /^[ \n\r\t\f]/.test(chunk), /[ \n\r\t\f]$/.test(chunk));
        }
        return chunk;
      });
    }
    : identity, uidIgnore
    ? function (str) {
      return str.replace(new RegExp('<!--' + uidIgnore + '([0-9]+)-->', 'g'), function (match, index) {
        return ignoredMarkupChunks[+index];
      });
    }
    : identity);
}

function joinResultSegments(results, options, restoreCustom, restoreIgnore) {
  let str;
  const maxLineLength = options.maxLineLength;
  const noNewlinesBeforeTagClose = options.noNewlinesBeforeTagClose;

  if (maxLineLength) {
    let line = ''; const lines = [];
    while (results.length) {
      const len = line.length;
      const end = results[0].indexOf('\n');
      const isClosingTag = Boolean(results[0].match(endTag));
      const shouldKeepSameLine = noNewlinesBeforeTagClose && isClosingTag;

      if (end < 0) {
        line += restoreIgnore(restoreCustom(results.shift()));
      } else {
        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));
        results[0] = results[0].slice(end + 1);
      }
      if (len > 0 && line.length > maxLineLength && !shouldKeepSameLine) {
        lines.push(line.slice(0, len));
        line = line.slice(len);
      } else if (end >= 0) {
        lines.push(line);
        line = '';
      }
    }
    if (line) {
      lines.push(line);
    }
    str = lines.join('\n');
  } else {
    str = restoreIgnore(restoreCustom(results.join('')));
  }
  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;
}

/**
 * Initialize minification caches with configurable sizes.
 *
 * Important behavior notes:
 * - Caches are created on the first `minify()` call and persist for the lifetime of the process
 * - Cache sizes are locked after first initialization—subsequent calls use the same caches
 *   even if different `cacheCSS`/`cacheJS` options are provided
 * - The first call’s options determine the cache sizes for subsequent calls
 * - Explicit `0` values are coerced to `1` (minimum functional cache size)
 */
function initCaches(options) {
  // Only create caches once (on first call)—sizes are locked after this
  if (!cssMinifyCache) {
    const defaultSize = 500;

    // Helper to parse env var—returns parsed number (including 0) or undefined if absent, invalid, or negative
    const parseEnvCacheSize = (envVar) => {
      if (envVar === undefined) return undefined;
      const parsed = Number(envVar);
      if (Number.isNaN(parsed) || !Number.isFinite(parsed) || parsed < 0) {
        return undefined;
      }
      return parsed;
    };

    // Get cache sizes with precedence: Options > env > default
    const cssSize = options.cacheCSS !== undefined ? options.cacheCSS
                 : (parseEnvCacheSize(process.env.HMN_CACHE_CSS) ?? defaultSize);
    const jsSize = options.cacheJS !== undefined ? options.cacheJS
                 : (parseEnvCacheSize(process.env.HMN_CACHE_JS) ?? defaultSize);

    // Coerce `0` to `1` (minimum functional cache size) to avoid immediate eviction
    const cssFinalSize = cssSize === 0 ? 1 : cssSize;
    const jsFinalSize = jsSize === 0 ? 1 : jsSize;

    cssMinifyCache = new LRU(cssFinalSize);
    jsMinifyCache = new LRU(jsFinalSize);
  }

  return { cssMinifyCache, jsMinifyCache };
}

/**
 * @param {string} value
 * @param {MinifierOptions} [options]
 * @returns {Promise<string>}
 */
const minify = async function (value, options) {
  const start = Date.now();

  // Initialize caches on first use with configurable sizes
  const caches = initCaches(options || {});

  options = processOptions(options || {}, {
    getLightningCSS,
    getTerser,
    getSwc,
    ...caches
  });
  let result = await minifyHTML(value, options);

  // Post-processing: Merge consecutive inline scripts if enabled
  if (options.mergeScripts) {
    result = mergeConsecutiveScripts(result);
  }

  options.log('minified in: ' + (Date.now() - start) + 'ms');
  return result;
};

var htmlminifier = { minify, presets, getPreset, getPresetNames };

exports.default = htmlminifier;
exports.getPreset = getPreset;
exports.getPresetNames = getPresetNames;
exports.minify = minify;
exports.presets = presets;
