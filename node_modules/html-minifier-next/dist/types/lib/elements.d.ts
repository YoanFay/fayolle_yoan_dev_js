export function canRemoveParentTag(optionalStartTag: any, tag: any): boolean;
export function isStartTagMandatory(optionalEndTag: any, tag: any): boolean;
export function canRemovePrecedingTag(optionalEndTag: any, tag: any): boolean;
export function canRemoveElement(tag: any, attrs: any): boolean;
/**
 * @param {string} str - Tag name or HTML-like element spec (e.g., “td” or “<span aria-hidden='true'>”)
 * @param {MinifierOptions} options - Options object for name normalization
 * @returns {{tag: string, attrs: Object.<string, string|undefined>|null}|null} Parsed spec or null if invalid
 */
export function parseElementSpec(str: string, options: MinifierOptions): {
    tag: string;
    attrs: {
        [x: string]: string | undefined;
    } | null;
} | null;
/**
 * @param {string[]} input - Array of element specifications from `removeEmptyElementsExcept` option
 * @param {MinifierOptions} options - Options object for parsing
 * @returns {Array<{tag: string, attrs: Object.<string, string|undefined>|null}>} Array of parsed element specs
 */
export function parseRemoveEmptyElementsExcept(input: string[], options: MinifierOptions): Array<{
    tag: string;
    attrs: {
        [x: string]: string | undefined;
    } | null;
}>;
/**
 * @param {string} tag - Element tag name
 * @param {HTMLAttribute[]} attrs - Array of element attributes
 * @param {Array<{tag: string, attrs: Object.<string, string|undefined>|null}>} preserveList - Parsed preserve specs
 * @returns {boolean} True if the empty element should be preserved
 */
export function shouldPreserveEmptyElement(tag: string, attrs: HTMLAttribute[], preserveList: Array<{
    tag: string;
    attrs: {
        [x: string]: string | undefined;
    } | null;
}>): boolean;
//# sourceMappingURL=elements.d.ts.map